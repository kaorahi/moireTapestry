<!DOCTYPE HTML>
<html>
<head>
 <meta charset="UTF-8" />
 <title>Moire Tapestry</title>
 <style>
  #mainCanvasContainer {
    display: inline-block; margin-bottom: 0.5em; padding: none;
    border: 1px solid black;
    box-shadow: 2px 6px 10px gray; transition: box-shadow 0.2s;
  }
  #mainCanvasContainer:hover {
    box-shadow: 4px 12px 20px black; transition: box-shadow 0.2s;
  }
  #gallery img {
    border: solid 2px transparent; margin: 0.3em; padding: 0;
    box-shadow: 1px 3px 5px gray; transition: transform 0.1s;
  }
  #gallery img[data-current="yes"] {box-shadow: 4px 12px 20px black;}
  #gallery img:hover {
    border: solid 2px blue; transform: scale(1.5); transition: transform 0.1s;
  }
  #control {
    display: inline-block; text-align: center; padding: 2vmin; background: #ccc;
    border-radius: 1vmin;
  }
  #blur, #speed {width: 15vmin;}
  #coef {width: 7em;}
  #coef[data-valid="no"] {background: pink;}
  #download + span {display: none;}
  #download[hidden] + span {display: inline; color: #ddd;}
  #palette span:not(.tooltip-origin) {margin: 1px; padding: 0; border: solid 1px black;}
  .thin {opacity: 0.2;}
  .small * {font-size: 70%;}
  #colorEditor {
   background-color: white; margin-bottom: 0.2em; padding: 0.2em;
   animation: VerticalOpen 0.2s;
  }
  @keyframes VerticalOpen {
   0% {transform: scaleY(0);}
   90% {transform: scaleY(1.2);}
   100% {transform: scaleY(1);}
  }
  #colorEditor input[type="color"] {width: 2em;}
  #toast {
   position: fixed; top: 0; left: 0; width: 100%; height: 100%;
   display: flex; justify-content: center; align-items: center;
   opacity: 0; pointer-events: none;
  }
  #toastMessage {
   max-width: 50vw; overflow-wrap: anywhere;
   color: white; background-color: black;
   padding: 0.5em; border-radius: 1em; z-index: 9; position: relative;
  }
  .tooltip-origin {position: relative; display: inline-block;}
  [data-tooltip] {width: 2em; height: 2em;}
  [data-tooltip]:hover:after {
   content: attr(data-tooltip); display: inline-block; position: absolute;
   background-color: #ff9; padding: 0.2em;
   z-index: 9; top: 2em; left: 0em; white-space: nowrap;
  }
  [data-tooltip]:after {content: "";}
  #galleryController {
   background-color: #ddd; padding: 0.2em; position: sticky; top: 0;
  }
 </style>
 <script>
 'use strict'
 window.onload = () => {
  
  // param
  const resolutionList = [[101, 4], [151, 4], [201, 2], [401, 1], [51, 8]];
  let [resolution, mainUnit] = resolutionList[0];
  const mainPictureSize = '70vmin';
  const maxRandomColors = 16;
  const coefURLDigits = 7;
  const horizontalDragStep = 0.01;
  const verticalDragStep = horizontalDragStep * 0.01;
  const wheelStep = verticalDragStep * 0.001;
  const kbdFastStep = horizontalDragStep;
  const kbdSlowStep = verticalDragStep;
  const kbdFineStep = kbdSlowStep * 0.1;
  const defaultBlur = 0.15, blurDigits = 2;
  const defaultAutoSpeed = 7, autoStep = wheelStep, autoMillisec = 100;
  const doubleTapMillisec = 500, doubleTapDistance = 100;
  const downloadLinkDelayMillisec = 500;
  const variationNums = {coefs: 100, colors: 90, alts: 10, shuffles: true};
  const mixedVariationNums = {coefs: 50, colors: 40, alts: 10, shuffles: true};
  const altColorVariations = 100;
  const randColorEnhance = {s: 5.0, l: 5.0}; // >= 1
  
  // samples
  const galleryCoef = [
    0.1199, 0.1478, 0.3125, 0.6491, 0.6521, 0.7274, 0.7693, 0.7742, 0.8184,
    1.1818, 1.4634, 1.5482, 1.5600, 1.5652, 1.5937,
    2.1419, 2.3566, 2.4080, 2.6071, 2.6143, 2.6341, 2.6352, 2.7694,
    3.5450, 3.5807, 3.6164, 3.7199, 3.7272,
    4.1471, 4.2985, 4.3632, 4.3902, 4.5334, 4.5886, 4.7727,
    5.1179, 5.2108, 5.3794, 5.4286, 5.6188, 5.6343, 5.6400, 5.7097, 5.8076,
    6.2432, 6.2718, 6.3716, 6.3829, 6.3846, 6.5290, 6.6486,
    7.1642, 7.2852, 7.3500, 7.4000, 7.6500, 7.7289,
    8.4782, 8.5385, 8.5389, 8.5455, 8.6129, 8.6412, 8.8333, 8.8415, 8.8800,
    9.3156, 9.6667, 9.8050, 9.8712,
    10.5883, 10.6799, 10.6956, 10.7728,
    11.1891, 11.3906, 11.6500, 11.6758, 11.6799, 11.8064,
  ].sort((a, b) => a - b);
  const galleryUnit = 2;
  const galleryPictureSizeSML = ['5vw', '11vw', '22vw'];
  const defaultCoef = 3.6164;
  
  // color tables
  const colorTableList = [
    // light
    ['white', 'orange', 'white', 'pink', 'white', 'red', 'white', 'magenta', 'white', 'yellow', 'white', 'blue'],
    // dense light
    ['white', 'brown', 'orange', 'white', 'pink', 'red', 'white', 'khaki', 'magenta', 'white', 'yellow', 'blue'],
    // red
    ['red', 'white', 'red', 'red', 'white', 'white', 'red', 'navy', 'green', 'white', 'silver', 'gold'],
    // brown
    ['#fc9', '#c33', '#633', '#fc9', '#fff', '#cff', '#f96', '#cff', '#fff', '#c33', '#f96', '#633'],
    // brown blobs
    ['#fc9', '#f96', '#c33', '#633', '#cff', '#fff', '#fc9', '#f96', '#c33', '#633', '#cff', '#fff'],
    // black & white
    ['black', 'white', 'white', 'white'],
    // four colors
    ['#f00', '#fff', '#fff', '#fff', '#366', '#fff', '#fff', '#f60', '#00c', '#fff', '#fff', '#fff'],
  ];
  const defaultColorTable = colorTableList[0].slice();
  
  // state
  let mainCoef = defaultCoef;
  let colorTable = defaultColorTable;
  let useGPU = false;
  let galleryPictureSize = galleryPictureSizeSML[0];
  let autoTimer = null;
  
  // init
  let mainCanvas, internalCanvas;
  const updateDownloadLink = downloadLinkUpdater();
  const [smallGallery, mediumGallery, largeGallery] =
    galleryPictureSizeSML.map(size => () => setGallerySize(size));
  readURL();
  updateCanvas();
  updateCoefForm();
  showDefaultGallery();
  initializeUI();
  update();
  !location.search && startAuto();
  
  // main
  function update(isNewSetting) {
    isNewSetting && updateCanvas();
    normalizeMainCoef();
    draw(mainCoef);
    updateGallery();
  }
  function draw(coef, ctable, canvas, unit) {
    const cv = canvas || mainCanvas;
    const args = [coef, ctable || colorTable, cv, unit || mainUnit];
    const usingGPU = drawGPU(...args) || drawCPU(...args);
    if (cv !== mainCanvas) {return;}
    Q('#state').innerText = usingGPU ? '(GPU) ' : '';
    updateDownloadLink();
  }
  
  // draw
  function drawCPU(coef, ctable, canvas, unit) {
    const g = canvas.getContext('2d');
    const center = Math.floor(resolution / 2);
    function sqr(k) {return k * k;}
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        const k = Math.floor(coef * (sqr(i - center) + sqr(j - center)));
        const style = ctable[k % ctable.length];
        fillSquare(g, i * unit, j * unit, unit, style);
      }
    }
    return false;
  }
  function drawGPU(coef, ctable, canvas, unit) {
    if (!useGPU || !isTwglAvailable()) {return false;}
    const gl = canvas.getContext('webgl');
    if (!gl) {return false;}
    const shaders = ['vertex_shader', 'fragment_shader'];
    const programInfo = twgl.createProgramInfo(gl, shaders);
    const arrays = {position: {numComponents: 2, data: [-1,-1, 1,-1, -1,1, 1,1]}};
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
    const cvec = getColorVectors(ctable);
    // dummy texture to use colorTable in GPU
    const src = cvec.flat(), numColors = cvec.length;
    const colorTexture = twgl.createTexture(gl, {src, width: numColors, height: 1})
    const uniforms = {resolution, unit, coef, numColors, colorTexture};
    gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    twgl.setUniforms(programInfo, uniforms);
    twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLE_STRIP);
    return true;
  }
  function isTwglAvailable() {return typeof twgl !== 'undefined';}
  
  // drag
  function setMouseActions(canvas) {
    let prevPoint = null;
    canvas.onmousedown = e => {prevPoint = mouseEventPoint(e);}
    canvas.onmouseleave = document.onmouseup = e => {prevPoint = null;}
    canvas.onmousemove = e => {
      if (!prevPoint) {return;}
      const point = mouseEventPoint(e);
      const [dx, dy] = [point.x - prevPoint.x, - (point.y - prevPoint.y)];
      const horizontal = Math.abs(dx) > Math.abs(dy);
      addCoef(horizontal ? dx * horizontalDragStep : dy * verticalDragStep);
      prevPoint = point;
    }
    canvas.onwheel = e => {e.preventDefault(); addCoef(e.deltaY * wheelStep);}
    setSwipeActions(canvas);
  }
  function mouseEventPoint(e) {return {x: e.clientX, y: e.clientY};}
  
  // swipe
  function setSwipeActions(canvas) {
    // accept swipe only after double tap
    let swipable = false, lastTap = null;
    const touchEquiv = [
      // [ontouchXXX, onmouseXXX, preProc, postProc]
      ['start', 'down', startTouch, null],
      ['move', 'move', null, null],
      ['end', 'leave', null, endTouch],
      ['cancel', 'leave', null, endTouch],
    ];
    touchEquiv.forEach(([touchName, mouseName, preProc, postProc]) => {
      function maybe(f, ...a) {f && f(...a);}
      canvas['ontouch' + touchName] = e => {
        const t = e.changedTouches[0];  // ignore multi-touch
        if (!t) {return;}
        maybe(preProc, t);
        if (!swipable) {return;}
        canvas['onmouse' + mouseName](t);
        e.preventDefault();
        maybe(postProc);
      }
    });
    // detect double tap
    function startTouch(e) {
      if (swipable) {return;}
      const time = Date.now(), point = mouseEventPoint(e);
      const immediate = lastTap && (time - lastTap.time <= doubleTapMillisec);
      const isDoubleTap = immediate && near(point, lastTap.point);
      const isNewTap = !isDoubleTap;
      swipable = isDoubleTap;
      lastTap = isNewTap && {time, point};
      isNewTap ? showDoubleTapHint() : cancelDoubleTapHint();
    }
    function endTouch() {swipable = false;}
    function near(a, b) {
      function near1(key) {return Math.abs(a[key] - b[key]) <= doubleTapDistance;}
      return ['x', 'y'].every(near1);
    }
    // show hint
    let doubleTapHintTimer = null;
    function showDoubleTapHint() {
      const show = () => toast('Double Tap & Swipe!');
      cancelDoubleTapHint();
      doubleTapHintTimer = setTimeout(show, doubleTapMillisec * 1.1);
    }
    function cancelDoubleTapHint() {clearTimeout(doubleTapHintTimer);}
  }
  
  // keyboard
  document.onkeydown = e => {
    const isStopped = stopAuto();
    if (e.target.tagName === 'INPUT') {return;}
    // allow auto-repeat
    switch (e.key) {
    case '<': addCoef(- kbdFastStep); return;
    case '>': addCoef(+ kbdFastStep); return;
    case ',': addCoef(- kbdSlowStep); return;
    case '.': addCoef(+ kbdSlowStep); return;
    case '[': addCoef(- kbdFineStep); return;
    case ']': addCoef(+ kbdFineStep); return;
    case '(': prevGallery(); return;
    case ')': nextGallery(); return;
    }
    // ignore auto-repeat
    if (e.repeat) {return;}
    switch (e.key) {
    case 'c': copyCoef(); return;
    case 'a': !isStopped && startAuto(); return;
    case 'f': toggleFullScreen(); return;
    case 'z': rotateGallerySize(); return;
    case 'R': rotateResolution(); return;
    case 'x': case 'X': exitFullScreen(() => showPresetColorVariations(e)); return;
    case 'V': exitFullScreen(showDefaultMixedVariations); return;
    case 'g': scrollToTop(); return;
    case 'm': scrollToMid(); return;
    case 'G': e.ctrlKey ? (toggleGPU(), e.preventDefault()) : scrollToBot(); return;
    }
  }
  
  // color table
  function copyColorTable() {
    copyToClipboard(JSON.stringify(colorTable));
    setColorTable(colorTable); // to show color table as side effect
  }
  function randomColorTable() {
    const r = Math.random(), n = rand(maxRandomColors - 1) + 2;
    const randColor = randColorGenerator();
    let c = randColor();
    function generateColor() {Math.random() < r && (c = randColor()); return c;}
    const a = [...Array(n)].map(generateColor);
    const isSingleColor = a.every(z => z === a[0]);
    return isSingleColor ? randomColorTable() : shuffle(a);
  }
  function randomlyReplacedColorTable(ctable) {
    const randColor = randColorGenerator();
    const oldColor = uniq(ctable);
    const newColor = oldColor.map(randColor);
    return ctable.map(c => newColor[oldColor.indexOf(c)]);
  }
  function setColorTable(table) {
    colorTable = table.slice();
    update(true);
    updateURL();
    updateColorEditor();
  }
  function showColorTable() {
    const container = Q('#palette');
    container.innerHTML = '';
    colorTable.forEach(c => {
      const t = document.createElement('div');
      t.classList.add('tooltip-origin');
      const elem = document.createElement('span');
      elem.style.backgroundColor = c;
      elem.dataset.tooltip = c;
      elem.innerHTML = '&nbsp;';
      container.appendChild(t);
      t.appendChild(elem);
    });
    Q('#paletteColorNum').innerText = uniq(colorTable).length;
  }
  /* function encodeColorTable(a) {return a.join('_');} */
  /* function decodeColorTable(s) {return s.split('_');} */
  function encodeColorTable(a) {return JSON.stringify(a);}
  function decodeColorTable(s) {
    try {return JSON.parse(s);} catch {return defaultColorTable;}
  }
  function isSameColorTable(ctable1, ctable2) {
    const [s1, s2] = [ctable1, ctable2].map(encodeColorTable);
    return (s1 === s2);
  }
  
  // color editor
  let oldColorTable;
  Q('#groupwise').onchange = updateColorEditor;
  function showColorEditor() {
    updateColorEditor();
    Q('#colorEditor').hidden = false;
    Q('#showColorEditor').disabled = true;
  }
  function finishColorEditor(newColorTable) {
    setColorTable(newColorTable);
    Q('#colorEditor').hidden = true;
    Q('#showColorEditor').disabled = false;
  }
  function acceptColorEditor() {finishColorEditor(colorTable);}
  function cancelColorEditor() {finishColorEditor(oldColorTable);}
  function updateColorEditor() {
    oldColorTable = colorTable.slice();
    const initVal = normalizeColorTable(colorTable);
    const container = Q('#colorPickerContainer');
    container.innerHTML = '';
    function addPickers(a, setter) {
      a.forEach((c, k) => container.appendChild(colorPicker(c, k, setter)));
    }
    function addPickersIndividually() {
      addPickers(initVal, (k, v) => (colorTable[k] = v));
    }
    function addPickersGroupwise() {
      const uniqueColor = uniq(initVal);
      const group = uniqueColor.map(c => indicesOf(c, initVal));
      const setter = (k, v) => group[k].forEach(j => colorTable[j] = v);
      addPickers(uniqueColor, setter);
    }
    Q('#groupwise').checked ? addPickersGroupwise() : addPickersIndividually();
  }
  function colorPicker(initialValue, index, setter) {
    const p = document.createElement('input');
    p.type = 'color';
    p.value = initialValue;
    p.oninput = _ => {setter(index, p.value); update();};
    return p;
  }
  function normalizeColorTable(ctable) {
    function toHex(c) {return c.toString(16).padStart(2, '0');}
    function toRGB(v) {return `#${v.slice(0, 3).map(toHex).join('')}`};
    return getColorVectors(colorTable).map(toRGB);
  }
  
  // auto
  function startAuto() {
    cancelAuto();
    const step = Math.pow(2, toNum(Q('#speed').value)) * autoStep;
    autoTimer = setTimeout(() => {addCoef(step); startAuto();}, autoMillisec);
    Q('#startAuto').hidden = true;
    updateAutoButtons(true);
  }
  function stopAuto() {
    const isStopped = !!autoTimer;
    cancelAuto();
    updateAutoButtons(false);
    return isStopped;
  }
  function cancelAuto() {
    autoTimer && clearTimeout(autoTimer);
    autoTimer = null;
  }
  function updateAutoButtons(isStarted) {
    Q('#startAuto').hidden = isStarted;
    Q('#stopAuto').hidden = !isStarted;
  }
  function updateAutoSpeed() {
    Q('#speedVal').innerText = Q('#speed').value.padStart(2, '0');
    autoTimer && startAuto();
  }
  
  // UI parts
  const keepAuto = ['startAuto', 'fullScreen'];
  function initializeUI() {
    initializeButtons();
    initializeSliders();
    function stopAutoMaybe(e) {
      !keepAuto.includes(e.target.id) && (e.target.type !== 'range') && stopAuto();
    }
    document.addEventListener('click', stopAutoMaybe);
    window.onpopstate = e => {readURL(); update(true);};
    merge(Q('#coef'), {
      oninput: setCoefByForm,
      onkeydown: e => {e.key === 'Enter' && (e.target.blur(), updateCoefForm());},
    });
    updateBlur();
    updateAutoSpeed();
  }
  function initializeButtons() {
    // assume "id in HTML" = "function name in JS"
    const buttonAction = {
      copyURL, newTab, nextGallery, prevGallery, startAuto, stopAuto,
      copyCoef, fullScreen,
      smallGallery, mediumGallery, largeGallery,
      copyColorTable,
      showDefaultGallery, showCoefVariations, showColorVariations, showAltVariations,
      showPresetColorVariations, showDefaultMixedVariations,
      showPresetColorVariationsSimply,
      showColorEditor, acceptColorEditor, cancelColorEditor,
    }
    function setAction(id, action){Q('#' + id).onclick = action;}
    eachKeyValue(buttonAction, setAction);
  }
  function initializeSliders() {
    const sliderTable = [
      // id, value, oninput
      ['blur', defaultBlur, updateBlur],
      ['speed', defaultAutoSpeed, updateAutoSpeed],
    ];
    function setup([id, value, oninput]) {merge(Q('#' + id), {value, oninput});}
    sliderTable.forEach(setup);
  }
  function setGallerySize(size) {
    galleryPictureSize = size;
    updateGallery();
  }
  function rotateGallerySize() {
    setGallerySize(rotate(galleryPictureSize, galleryPictureSizeSML));
  }
  function updateBlur() {
    const b = Q('#blur').value;
    mainCanvas.style.filter = `blur(${b}vmin)`;
    Q('#blurVal').innerText = toNum(b).toFixed(blurDigits);
  }
  function downloadLinkUpdater() {
    function updateNow() {
      const href = mainCanvas.toDataURL('image/png');
      const download = `tapestry${encodeCoef(mainCoef)}.png`;
      merge(Q('#download'), {href, download, hidden: false});
    }
    const updateLater = deferredProc(updateNow, downloadLinkDelayMillisec);
    function f() {Q('#download').hidden = true; updateLater();}
    return f;
  }
  function toggleGPU() {
    if (!isTwglAvailable()) {toast('Missing TWGL.js'); return;}
    useGPU = !useGPU;
    removeMainCanvas(); // force reset
    internalCanvas = null; // force reset
    update(true);
    updateURL();
    toast(useGPU ? 'GPU' : 'CPU');
  }
  
  // fullscreen
  function fullScreen() {mainCanvas.requestFullscreen();}
  function toggleFullScreen() {exitFullScreen() || fullScreen();}
  function exitFullScreen(proc) {
    const exited = document.fullscreenElement && document.exitFullscreen();
    proc && (exited ? exited.then(() => setTimeout(proc, 100)) : proc());
    return exited;
  }
  
  // clipboard
  function copyURL() {updateURL(); copyToClipboard(location.href);}
  function copyToClipboard(text) {
    updateURL();
    navigator.clipboard.writeText(text);
    toast(text);
  }
  
  // coef
  function setCoef(newCoef, byForm) {
    mainCoef = newCoef;
    update();
    !byForm && updateCoefForm();
  }
  function addCoef(d) {setCoef(mainCoef + d);}
  function normalizeMainCoef() {mainCoef = normalizeCoef(mainCoef);}
  function normalizeCoef(coef, max) {
    function digitizeCoef(num) {return decodeCoef(encodeCoef(num))}
    const int = Math.floor(coef), frac = coef - int;
    return digitizeCoef(positiveMod(int, max || colorTable.length) + frac);
  }
  function encodeCoef(num) {return num.toFixed(coefURLDigits);}
  function decodeCoef(str) {return toNum(str);}
  function updateCoefForm() {
    const form = Q('#coef'), val = encodeCoef(mainCoef);
    form.value = val.includes('.') ? val.replace(/0+$/, '').replace(/[.]$/, '') : val;
    form.dataset.valid = 'yes';
  }
  function setCoefByForm() {
    const form = Q('#coef'), v = form.value, c = toNum(v);
    const valid = v.match(/^\d+[.]?\d*$/) && !Number.isNaN(c);
    form.dataset.valid = valid ? 'yes' : 'no'
    valid && setCoef(c, true);
  }
  function copyCoef() {copyToClipboard(encodeCoef(mainCoef));}
  function randCoef(max) {
    const m = max || colorTable.length;
    return normalizeCoef(Math.random() * m, m);
  }
  
  // canvas
  function replaceCanvasMaybe(canvas, unit, pictureSize) {
    // for GPU
    const w = expectedCanvasWidth(unit);
    const resized = !canvas || (canvas.width !== w);
    if (!resized) {return canvas;}
    canvas && canvas.remove();
    const newCanvas = document.createElement('canvas');
    setCanvasSize(newCanvas, unit, pictureSize);
    return newCanvas;
  }
  function updateInternalCanvas() {
    internalCanvas = replaceCanvasMaybe(internalCanvas, galleryUnit, galleryPictureSize);
  }
  function updateMainCanvas() {
    const oldCanvas = mainCanvas;
    mainCanvas = replaceCanvasMaybe(oldCanvas, mainUnit, mainPictureSize);
    if (mainCanvas === oldCanvas) {return;}
    mainCanvas.id = 'mainCanvas';
    Q('#mainCanvasContainer').appendChild(mainCanvas);
  }
  function updateCanvas() {
    updateMainCanvas();
    updateInternalCanvas();
    Q('#mod').innerText = colorTable.length;
    showColorTable();
    setMouseActions(mainCanvas);
    updateBlur();
  }
  function removeMainCanvas() {
    mainCanvas && mainCanvas.remove();
    mainCanvas = null;
  }
  function setCanvasSize(canvas, unit, pictureSize) {
    canvas.width = canvas.height = expectedCanvasWidth(unit);
    canvas.style.width = canvas.style.height = pictureSize;
  }
  function expectedCanvasWidth(unit) {return resolution * unit;}
  
  // graphics
  function fillSquare(g, x, y, size, style) {
    g.fillStyle = style;
    g.beginPath(); g.rect(x, y, size, size); g.fill();
  }
  function getColorVectors(colors) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 1;
    const ctx = canvas.getContext('2d');
    function rgbaVec(colorString) {
      fillSquare(ctx, 0, 0, 1, colorString);
      return [...ctx.getImageData(0, 0, 1, 1).data];
    }
    return colors.map(rgbaVec);
  }
  
  // URL
  function readURL() {
    colorTable = defaultColorTable;
    new URLSearchParams(location.search).forEach((value, key) => {
      switch (key) {
      case 'c': mainCoef = decodeCoef(value); break;
      case 'GPU': useGPU = true; break;
      case 'palette': colorTable = decodeColorTable(value); break;
      }
    })
  }
  function updateURL() {
    const url = generateURL(mainCoef);
    url !== location.href && history.pushState(null, document.title, url);
  }
  function newTab() {
    updateURL();
    window.open(generateURL(mainCoef), '_blank');
  }
  function generateURL(coef, optionColorTable) {
    const url = new URL(location.toString());
    const params = new URLSearchParams('');
    params.append('c', encodeCoef(coef));
    useGPU && params.append('GPU', 'y');
    const ctab = optionColorTable || colorTable;
    const [ct, dct] = [ctab, defaultColorTable].map(encodeColorTable);
    ct && ct !== dct && params.append('palette', ct);
    url.search = params.toString();
    return url.toString();
  }
  
  // gallery
  function showDefaultGallery(e) {
    const keepPosition = !e;
    const note = `These ${galleryCoef.length} patterns are generated from just one parameter c without randomness.`;
    showGallery(galleryCoef.map(c => [c, defaultColorTable]), note, keepPosition, true);
  }
  function isDefaultColorAndGallery() {
    const isDefaultGallery = Q('#showDefaultGallery').disabled; // fixme!
    return isDefaultGallery && isSameColorTable(colorTable, defaultColorTable);
  }
  function showGallery(ary, note, keepPosition, isDefaultGallery) {
    Q('#showDefaultGallery').disabled = isDefaultGallery;
    Q('#galleryNote').innerText = note || '';
    const gallery = Q('#gallery');
    gallery.innerHTML = '';
    ary.forEach(([c0, ct], k) => {
      const c = normalizeCoef(c0);
      const [a, img] = ['a', 'img'].map(tag => document.createElement(tag));
      a.href = generateURL(c, ct);
      a.appendChild(img);
      gallery.appendChild(a);
      setTimeout(() => drawGallery(c, ct, img));
      img.onclick = e => {
        e && e.preventDefault();
        e && e.shiftKey ? showMixedVariations(c, ct) :
          (openGallery(c, ct), setCurrentGallery(k));
      };
    });
    updateGallery();
    keepPosition === 'nearest' ? scrollToMidMaybe() :
      (!keepPosition && scrollToMid());
  }
  function drawGallery(coef, ctable, img) {
    draw(coef, ctable, internalCanvas, galleryUnit);
    img.src = internalCanvas.toDataURL('image/png');
  }
  function openGallery(coef, ctable) {
    scrollToTop();
    updateURL();
    setCoef(coef);
    setColorTable(ctable);
  }
  function nextGallery() {nextGalleryGen(+1, c => c > mainCoef, false);}
  function prevGallery() {nextGalleryGen(-1, c => c < mainCoef, true);}
  function nextGalleryGen(step, pred, reversed) {
    isDefaultColorAndGallery() ?
      openGallery(findGallery(pred, reversed), colorTable) : nextSample(step);
  }
  function nextSample(step) {
    const a = galleryImg(), k = getCurrentGalleryIndex();
    const next = positiveMod((k < 0 && step < 0) ? step : (k + step), a.length);
    a[next].onclick();
  }
  function findGallery(pred, reversed) {
    const orig = galleryCoef, a = reversed ? orig.slice().reverse() : orig;
    return a.find(pred) || a[0];
  }
  function updateGallery() {
    galleryImg().forEach((img, k) => {
      img.style.width = img.style.height = galleryPictureSize;
    });
    if (!isDefaultColorAndGallery()) {return;}
    const cur = galleryCoef.indexOf(findGallery(c => c >= mainCoef, false));
    setCurrentGallery(cur);
  }
  function setCurrentGallery(currentIndex) {
    galleryImg().forEach((img, k) => {
      img.dataset.current = yesNo(k === currentIndex);
    });
  }
  function getCurrentGalleryIndex() {
    return galleryImg().findIndex(img => img.dataset.current === yesNo(true));
  }
  function galleryImg() {return [...document.querySelectorAll('#gallery img')];}
  
  // variations
  function showPresetColorVariationsSimply() {
    showPresetColorVariationsGen(mainCoef, null, 'default order', 'nearest');
  }
  function showPresetColorVariations(e) {
    e && e.preventDefault();
    function numSlots(colors) {return colors.length;}
    function numColors(colors) {return uniq(colors).length;}
    const [_, sortingCriterion, info, keepPosition] = [
      ['shiftKey', numSlots, 'sorted by number of color slots', 'nearest'],
      ['ctrlKey', numColors, 'sorted by number of actual colors', 'nearest'],
      ['altKey', null, 'default order', 'nearest'],
      [null, Math.random, 'shuffled', false],
    ].find(([modifier]) => !modifier || (e || {})[modifier]);
    const c = randCoef(Math.max(...colorTableList.map(a => a.length)));
    showPresetColorVariationsGen(c, sortingCriterion, info, keepPosition);
  }
  function showPresetColorVariationsGen(c, sortingCriterion, info, keepPosition) {
    const ctabs = sortingCriterion ?
      sortBy(colorTableList, sortingCriterion) : colorTableList;
    const note = `${ctabs.length} preset colors for c = ${c} (${info})`
    showGallery(ctabs.map(ct => [c, ct]), note, keepPosition);
    const cur = ctabs.findIndex(ct => isSameColorTable(ct, colorTable));
    cur >= 0 && setCurrentGallery(cur);
  }
  function showCoefVariations() {
    const {coefs} = variationNums;
    showVariationsGen(mainCoef, colorTable, {coefs});
  }
  function showColorVariations() {
    const {colors, alts, shuffles} = variationNums;
    showVariationsGen(mainCoef, colorTable, {colors, alts, shuffles});
  }
  function showAltVariations() {
    showVariationsGen(mainCoef, colorTable, {alts: altColorVariations});
  }
  function showDefaultMixedVariations() {
    showVariationsGen(mainCoef, colorTable, mixedVariationNums);
  }
  function showMixedVariations(c, ctable) {
    setCoef(c);
    setColorTable(ctable);
    showDefaultMixedVariations();
  }
  function showVariationsGen(c, ctable, {coefs, colors, alts, shuffles}) {
    function ntimes(n, f) {return n ? [...Array(n)].map(f) : [];}
    const a1 = ntimes(coefs, _ => [randCoef(), ctable]);
    const a2 = ntimes(colors, _ => [c, randomColorTable()]);
    const a3 = ntimes(alts, _ => [c, randomlyReplacedColorTable(ctable)]);
    const a4 = shuffles ? ntimes(ctable.length - 1, _ => [c, shuffle(ctable)]) : [];
    showGallery([...a1, ...a2, ...a3, ...a4]);
  }

  // toast
  let lastToastAnimation = null;
  function toast(message, millisec) {
    lastToastAnimation && lastToastAnimation.finish();
    const tm = Q('#toastMessage');
    tm.innerText = message;
    tm.style.fontSize = (message.length < 20 ? '200%' : '150%');
    const keyframes = [{opacity: 1}, {opacity: 0.8}, {opacity: 0}];
    lastToastAnimation = Q('#toast').animate(keyframes, millisec || 3000);
  }
  
  // misc. actions
  function scrollToTop() {scrollTo('#instruction', 'nearest');}
  function scrollToMid() {scrollTo('#galleryTop', 'start');}
  function scrollToMidMaybe() {scrollTo('#samplesSection', 'nearest');}
  function scrollToBot() {scrollTo('#usage', 'end');}
  function scrollTo(query, block) {
    Q(query).scrollIntoView({behavior: 'smooth', block});
  }
  function rotateResolution() {
    [resolution, mainUnit] = rotate([resolution, mainUnit], resolutionList);
    update(true);
    scrollToTop();
  }
  
  // util
  function Q(query) {return document.querySelector(query);}
  function merge(target, ...sources) {Object.assign(target, ...sources);}
  function eachKeyValue(h, f) {Object.keys(h).forEach(k => f(k, h[k]));}
  function uniq(ary) {return [...new Set(ary)];}
  function indicesOf(x, ary) {return ary.flatMap((y, j) => x === y ? [j] : []);}
  function toNum(str) {return str - 0;}
  function yesNo(bool) {return bool ? 'yes' : 'no';}
  function positiveMod(x, mod) {return (x + mod) % mod;}
  function rand(n) {return Math.floor(Math.random() * n);}
  function randColorGenerator() {
    function modestRand(modest, range) {
      return Math.round(range * Math.random() ** modest);
    }
    function randomEnhance(enhance) {return enhance ** Math.random();}
    const enh = {s: randomEnhance(randColorEnhance.s),
                 l: randomEnhance(randColorEnhance.l)};
    function randColor() {
      const h = rand(360);
      const s = modestRand(1 / enh.s, 100);
      const lSign = Math.sign(Math.random() - 0.5);
      const l = 50 + lSign * modestRand(enh.l, 50);
      return `hsl(${h},${s}%,${l}%)`;
    }
    return randColor;
  }
  function shuffle(a) {return sortBy(a, Math.random);}
  function sortBy(a, f) {return a.slice().sort((x, y) => f(x) - f(y));}
  function rotate(cur, lis) {
    const conv = JSON.stringify;
    return lis[(lis.map(conv).indexOf(conv(cur)) + 1) % lis.length];
  }
  function deferredProc(proc, delay) {
    let timer;
    return (...args) => {
        clearTimeout(timer); timer = setTimeout(() => proc(...args), delay);
    }
  }
 }
 </script>
 <script defer src="twgl.min.js"></script>
 <script id="vertex_shader" type="non-js">
  attribute vec4 position;
  void main () {gl_Position = position;}
 </script>
 <script id="fragment_shader" type="non-js">
  precision mediump float;
  uniform float resolution, unit, coef, numColors;
  uniform sampler2D colorTexture;
  void main() {
    float center = floor(resolution / 2.0);
    vec2 coord = floor(vec2(gl_FragCoord.x / unit, gl_FragCoord.y / unit)) - center;
    float k = floor(mod(coef * dot(coord, coord), numColors));
    vec4 color = texture2D(colorTexture, vec2((k + 0.5) / numColors, 0.0));
    gl_FragColor = vec4(color.r, color.g, color.b, 1.0);
  }
 </script>
</head>

<body>
<h1>Moire Tapestry - Generative art in 1986</h1>
<p id="instruction">
 Drag the mouse on the picture! (wheel: fine tuning)
</p>
<div id="control">
<div id="mainCanvasContainer"></div>
<div id="colorEditor" hidden>
 <div>
  <span id="colorPickerContainer"></span>
  <input id="groupwise" type="checkbox"></input><label for="groupwise">grouping</label>
  &nbsp;
  <div class="tooltip-origin"><button id="copyColorTable" data-tooltip="Copy to Clipboard">⧉</button></div>
 </div>
 <div>
  <button id="acceptColorEditor">Ok</button>
  <button id="cancelColorEditor">Cancel</button>
 </div>
</div>
<div>
 <div class="tooltip-origin"><button id="startAuto" data-tooltip="Start Auto">▶</button><button id="stopAuto" hidden="true" data-tooltip="Stop Auto">⏸</button></div>
 speed <input id="speed" type="range" min="1" max="20" step="1"></input>
 <span class="thin" id="speedVal"></span>
 blur <input id="blur" type="range" min="0" max="1" step="0.01"></input>
 <span class="thin" id="blurVal"></span>
 <div class="tooltip-origin"><button id="prevGallery" data-tooltip="Previous Sample">&lt;</button></div>
 <div class="tooltip-origin"><button id="nextGallery" data-tooltip="Next Sample">&gt;</button></div>
 <div class="tooltip-origin"><button id="showDefaultMixedVariations" data-tooltip="Random Variations">⚃</button></div>
<div class="tooltip-origin"><button id="showColorEditor" data-tooltip="Edit Colors">🖍</button></div>
 <div class="tooltip-origin"><button id="fullScreen" data-tooltip="Full Screen">⤡</button></div>
</div>
</div>
<p>
<span id="state"></span>
c=<input id="coef" type="number" min="0" step="0.0001">
<button id="copyCoef">Copy</button>
&nbsp;
<button id="copyURL">Set &amp; Copy URL</button>
<button id="newTab">New Tab</button>
<a id="download">Download image</a><span>Download image</span>
</p>
<h2>What is this?</h2>
<p>
This is an interactive &amp; colorized version of the article:
<blockquote>
A. K. Dewdney:
"COMPUTER RECREATIONS",
Scientific American,
Vol. 255, No. 3, pp. 14-23,
September 1986.
</blockquote>
<blockquote>
("Wallpaper for the mind: computer images that are almost, but not quite, repetitive")
</blockquote>
The color at the point (x, y) is determined from
<blockquote>
floor(c * (x*x + y*y)) mod <span id="mod"></span>
in <span id="palette"></span>
(<span id="paletteColorNum"></span> colors)
</blockquote>
for the given parameter c.
</p>
<div id="samplesSection">
<h2>Samples</h2>
<span id="galleryTop"></span>
<p id="galleryController">
 size
 <button id="smallGallery">S</button>
 <button id="mediumGallery">M</button>
 <button id="largeGallery">L</button>
 &nbsp;
 <button id="showDefaultGallery">Gallery</button>
 <button id="showPresetColorVariations">Random Gallery</button>
 &nbsp;
 <span class="small">
  <button id="showCoefVariations">rand param</button>
  <button id="showColorVariations">rand colors</button>
  <button id="showAltVariations">alt colors</button>
  <button id="showPresetColorVariationsSimply">preset colors</button>
 </span>
</p>
<p id="galleryNote"></p>
<p id="gallery"></p>
</div><!-- samplesSection -->
<h2 id="usage">Advanced usage</h2>
<p>
<ul>
 <li>Fast change: horizontal drag or '<' / '>' key</li>
 <li>Slow change: vertical drag or ',' / '.' key</li>
 <li>Fine tuning: mouse wheel or '[' / ']' key</li>
 <li>Next/Previous sample: '(' / ')' key</li>
 <li>Copy c to clipboard: 'c' key</li>
 <li>Toggle auto: 'a' key</li>
 <li>Toggle full screen: 'f' key</li>
 <li>Switch sample picture size: 'z' key</li>
 <li>Show random gallery: 'x' key ('Shift/Ctrl/Alt-x' for sorting by "number of color slots" / "number of actual colors" / "default order" instead of shuffling)</li>
 <li>Generate random variations: 'Shift+v' key (or Shift+Click pictures in "Samples" section)</li>
 <li>Scroll to top/middle/bottom: 'g' / 'm' / 'Shift-g' key</li>
</ul>
<h3 class="thin">(experimental)</h3>
<ul class="thin">
 <li>Switch resolutions: 'Shift-r' key</li>
 <li>Toggle GPU: 'Ctrl-Shift-g' key (needs <a href="https://twgljs.org/">twgl.min.js</a>, e.g. <a href="https://github.com/greggman/twgl.js/releases/tag/v4.23.2">v4.23.2</a>)</li>
</ul>
</p>
<h2>Link</h2>
<p>
<a href="https://github.com/kaorahi/moireTapestry">Project Home</a>
</p>
<div id='toast'><p id='toastMessage'></p></div>
</body>
