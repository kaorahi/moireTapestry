<!DOCTYPE HTML>
<html>
<head>
 <meta charset="UTF-8" />
 <title>Moire Tapestry</title>
 <style>
  #mainCanvasContainer {
    display: inline-block; margin-bottom: 0.5em; padding: none;
    border: 1px solid black;
    box-shadow: 2px 6px 10px gray; transition: box-shadow 0.2s;
  }
  #mainCanvasContainer:hover {
    box-shadow: 4px 12px 20px black; transition: box-shadow 0.2s;
  }
  #gallery img {
    border: solid 2px transparent; margin: 0.3em; padding: 0;
    box-shadow: 1px 3px 5px gray; transition: transform 0.1s;
  }
  #gallery img[data-current="yes"] {box-shadow: 4px 12px 20px black;}
  #gallery img:hover {
    border: solid 2px blue; transform: scale(1.5); transition: transform 0.1s;
  }
  #gallery div:hover {z-index: 9;}
  #control {
    display: inline-block; text-align: center; padding: 2vmin; background: #ccc;
    border-radius: 1vmin;
  }
  #blur, #speed {width: 15vmin;}
  #coef {width: 7em;}
  #coef[data-valid="no"] {background: pink;}
  #download + span {display: none;}
  #download[hidden] + span {display: inline; color: #ddd;}
  #palette span:not(.tooltip-origin) {margin: 1px; padding: 0; border: solid 1px black;}
  .thin {opacity: 0.2;}
  .small * {font-size: 70%;}
  #colorEditor {
   background-color: white; margin-bottom: 0.2em; padding: 0.2em;
   animation: VerticalOpen 0.2s;
  }
  @keyframes VerticalOpen {
   0% {transform: scaleY(0);}
   90% {transform: scaleY(1.2);}
   100% {transform: scaleY(1);}
  }
  #colorEditor input[type="color"] {width: 2em;}
  #pasteColorTable {width: 2em;}
  #toast {
   position: fixed; top: 0; left: 0; width: 100%; height: 100%;
   display: flex; justify-content: center; align-items: center;
   opacity: 0; pointer-events: none;
  }
  #toastMessage {
   max-width: 50vw; overflow-wrap: anywhere;
   color: white; background-color: black;
   padding: 0.5em; border-radius: 1em; z-index: 9; position: relative;
  }
  .tooltip-origin {position: relative; display: inline-block;}
  button[data-tooltip] {width: 2em; height: 2em;}
  [data-tooltip]:hover:after {
   content: attr(data-tooltip); display: inline-block; position: absolute;
   color: black; background-color: #ff9; padding: 0.2em;
   z-index: 9; top: 100%; left: 0%; white-space: nowrap;
  }
  #gallery [data-tooltip]:hover:after {top: 125%;}
  [data-tooltip]:after {content: "";}
  #galleryController {
   background-color: #ddd; padding: 0.2em; position: sticky; top: 0; z-index: 10;
  }
  #pickColors img {max-width: 2em; max-height: 1em; transition: transform 0.1s;}
  #pickColors:hover img {
    border: solid 1px black; box-sizing: border-box;
    transform: translate(500%,500%) scale(10); transition: transform 0.1s;
  }
 </style>
 <script>
 'use strict'
 window.onload = () => {
  
  // param
  const resolutionList = [[101, 4], [151, 4], [201, 2], [401, 1], [51, 8]];
  let [resolution, mainUnit] = resolutionList[0];
  const mainPictureSize = '70vmin';
  const maxRandomColors = 16;
  const coefURLDigits = 7;
  const horizontalDragStep = 0.01;
  const verticalDragStep = horizontalDragStep * 0.01;
  const wheelStep = verticalDragStep * 0.001;
  const kbdFastStep = horizontalDragStep;
  const kbdSlowStep = verticalDragStep;
  const kbdFineStep = kbdSlowStep * 0.1;
  const defaultBlur = 0.15, blurDigits = 2;
  const defaultAutoSpeed = 7, autoStep = wheelStep, autoMillisec = 100;
  const doubleTapMillisec = 500, doubleTapDistance = 100;
  const downloadLinkDelayMillisec = 500;
  const variationNums = {coefs: 100, colors: 90, alts: 10, shuffles: true};
  const mixedVariationNums = {coefs: 50, colors: 40, alts: 10, shuffles: true};
  const altColorVariations = 100;
  const randColorEnhance = {s: 5.0, l: 5.0}; // >= 1
  const pickedColorsFromPastedImage =
    {minColors: 3, maxColors: 32, sets: 10, coefs: 10};
  
  // samples
  const galleryCoef = [
    0.1199, 0.1478, 0.3125, 0.6491, 0.6521, 0.7274, 0.7693, 0.7742, 0.8184,
    1.1818, 1.4634, 1.5482, 1.5600, 1.5652, 1.5937,
    2.1419, 2.3566, 2.4080, 2.6071, 2.6143, 2.6341, 2.6352, 2.7694,
    3.5450, 3.5807, 3.6164, 3.7199, 3.7272,
    4.1471, 4.2985, 4.3632, 4.3902, 4.5334, 4.5886, 4.7727,
    5.1179, 5.2108, 5.3794, 5.4286, 5.6188, 5.6343, 5.6400, 5.7097, 5.8076,
    6.2432, 6.2718, 6.3716, 6.3829, 6.3846, 6.5290, 6.6486,
    7.1642, 7.2852, 7.3500, 7.4000, 7.6500, 7.7289,
    8.4782, 8.5385, 8.5389, 8.5455, 8.6129, 8.6412, 8.8333, 8.8415, 8.8800,
    9.3156, 9.6667, 9.8050, 9.8712,
    10.5883, 10.6799, 10.6956, 10.7728,
    11.1891, 11.3906, 11.6500, 11.6758, 11.6799, 11.8064,
  ].sort((a, b) => a - b);
  const galleryUnit = 2;
  const galleryPictureSizeSML = ['5vw', '11vw', '22vw'];
  const defaultCoef = 3.6164;
  
  // color tables
  const colorTableList = [
    // light
    ['white', 'orange', 'white', 'pink', 'white', 'red', 'white', 'magenta', 'white', 'yellow', 'white', 'blue'],
    // dense light
    ['white', 'brown', 'orange', 'white', 'pink', 'red', 'white', 'khaki', 'magenta', 'white', 'yellow', 'blue'],
    // red
    ['red', 'white', 'red', 'red', 'white', 'white', 'red', 'navy', 'green', 'white', 'silver', 'gold'],
    // brown
    ['#fc9', '#c33', '#633', '#fc9', '#fff', '#cff', '#f96', '#cff', '#fff', '#c33', '#f96', '#633'],
    // brown blobs
    ['#fc9', '#f96', '#c33', '#633', '#cff', '#fff', '#fc9', '#f96', '#c33', '#633', '#cff', '#fff'],
    // black & white
    ['black', 'white', 'white', 'white'],
    // four colors
    ['#f00', '#fff', '#fff', '#fff', '#366', '#fff', '#fff', '#f60', '#00c', '#fff', '#fff', '#fff'],
    // brown + blue
    ["#925","#028","#efe","#c38","#db5","#efe"],
    // stained glass
    ["#fe3","#4df","#a49","#96a","#23d","#ddf","#c03","#1dc","#100","#21c","#42e","#100","#45d","#100","#100"],
    // illumination
    ["#601","#e90","#df5","#676","#40b","#df5","#40b","#e90","#3ba","#676","#676","#40b"],
    // fluorescence
    ["hsl(58,87%,49%)","hsl(170,97%,50%)","hsl(212,67%,44%)","hsl(212,67%,44%)","hsl(170,97%,50%)","hsl(212,67%,44%)","hsl(228,80%,27%)","hsl(246,100%,49%)","hsl(239,74%,26%)","hsl(301,84%,68%)"],
    // red + yellow
    ["#bd071e","#464845","#be092a","#0f0e0c","#c40419","#fab550","#ba0629","#c40526","#ffc33f","#f6f14d","#84583f","#d9cda3","#b18b5a","#f7fbfc","#c51347","#b78d5d","#9a7a61","#b70620","#353128","#d4e3ff"],
    // another illumination
    ["#6dd000","#8b3e06","#02162f","#db4729","#a7b730","#bb7520","#ffd668","#021f3f","#031e3c","#011837","#0c1e42","#973826","#9f4715","#001f40","#02162e","#03223e","#031e3c","#03172f","#874207","#01152e","#313900","#23e52d","#abdaa4","#7d3916","#5f761e","#efa661","#301e14","#011b32"],
    // peering
    ["#010920","#070b2e","#1c5b8e","#fdc5b6","#1d54a4","#060a2d","#020923","#dcdce6","#002e66","#c7d3ed","#e0eaf3","#94949c","#05081b","#2c66af"],
    // beige
    ["hsl(225,50%,44%)","hsl(245,87%,80%)","hsl(323,47%,91%)","hsl(3,66%,62%)","hsl(76,46%,31%)","hsl(35,74%,46%)","hsl(7,66%,90%)","hsl(164,56%,87%)","hsl(44,82%,94%)","hsl(18,38%,90%)","hsl(76,46%,31%)"],
    // dark colors
    ["hsl(161,93%,9%)","hsl(239,78%,45%)","hsl(239,78%,45%)","hsl(355,53%,100%)","hsl(49,69%,61%)","hsl(292,93%,3%)","hsl(8,54%,54%)","hsl(161,93%,9%)","hsl(161,100%,50%)","hsl(40,69%,50%)","hsl(8,54%,54%)","hsl(132,48%,8%)","hsl(279,65%,38%)","hsl(239,78%,45%)"],
    // green + black
    ["hsl(58,60%,60%)","hsl(54,85%,4%)","hsl(194,98%,63%)","hsl(329,47%,3%)","hsl(172,91%,19%)","hsl(156,78%,55%)","hsl(156,78%,55%)","hsl(58,60%,60%)","hsl(289,79%,5%)","hsl(319,58%,9%)","hsl(156,78%,55%)","hsl(166,43%,21%)","hsl(288,89%,19%)","hsl(172,91%,19%)"],
    // dark green
    ["hsl(53,81%,1%)","hsl(140,76%,37%)","hsl(53,81%,1%)","hsl(270,56%,93%)","hsl(270,56%,93%)","hsl(140,76%,37%)","hsl(53,81%,1%)","hsl(140,76%,37%)","hsl(152,52%,19%)","hsl(53,81%,1%)","hsl(152,52%,19%)"],
    // white + red
    ["hsl(52,57%,52%)","hsl(219,65%,96%)","hsl(219,65%,96%)","hsl(219,65%,96%)","hsl(343,92%,48%)","hsl(219,65%,96%)","hsl(52,57%,52%)","hsl(251,92%,5%)","hsl(219,65%,96%)"],
    // red + white
    ["hsl(117,72%,91%)","hsl(117,72%,91%)","hsl(280,80%,28%)","hsl(117,72%,91%)","hsl(280,63%,50%)","hsl(0,88%,48%)"],
    // three colors
    ["hsl(352,84%,50%)","hsl(86,91%,89%)","hsl(255,45%,50%)"],
    // brown + pale green
    ["hsl(202,84%,99%)","hsl(322,84%,95%)","hsl(89,80%,75%)","hsl(326,69%,32%)","hsl(89,83%,97%)","hsl(44,99%,27%)","hsl(69,32%,4%)","hsl(326,69%,32%)","hsl(130,70%,99%)","hsl(29,76%,17%)","hsl(202,84%,99%)"],
    // dark red
    ["hsl(256,97%,93%)","hsl(245,80%,81%)","hsl(1,93%,20%)","hsl(170,82%,92%)","hsl(347,95%,41%)","hsl(236,83%,25%)","hsl(21,76%,32%)","hsl(347,95%,41%)","hsl(283,48%,35%)","hsl(356,96%,79%)"],
    // red + green
    ["hsl(305,52%,94%)","hsl(341,70%,56%)","hsl(245,59%,2%)","hsl(341,70%,56%)","hsl(38,91%,91%)","hsl(144,71%,71%)","hsl(173,88%,79%)","hsl(341,77%,47%)","hsl(305,52%,94%)","hsl(224,51%,40%)","hsl(98,41%,36%)"],
    // red + light green
    ["hsl(97,86%,96%)","hsl(346,65%,48%)","hsl(122,86%,58%)","hsl(358,65%,92%)","hsl(136,21%,56%)","hsl(151,61%,83%)","hsl(289,67%,47%)","hsl(352,49%,48%)","hsl(53,78%,51%)","hsl(346,98%,51%)","hsl(358,96%,35%)"],
    // yellow + black
    ["hsl(348,79%,52%)","hsl(198,44%,45%)","hsl(283,95%,54%)","hsl(55,59%,57%)","hsl(220,36%,25%)","hsl(50,49%,15%)","hsl(87,24%,77%)","hsl(55,59%,57%)","hsl(11,92%,75%)","hsl(87,24%,77%)","hsl(132,43%,99%)","hsl(21,42%,86%)","hsl(65,78%,8%)"],
    // dark green + orange
    ["hsl(126,90%,26%)","hsl(25,89%,89%)","hsl(16,24%,7%)","hsl(126,90%,26%)","hsl(25,89%,89%)","hsl(127,96%,87%)","hsl(127,96%,87%)","hsl(28,80%,59%)","hsl(283,90%,7%)","hsl(283,90%,7%)","hsl(283,90%,7%)","hsl(283,90%,7%)","hsl(126,90%,26%)"],
    // gray
    ["hsl(127,4%,47%)","hsl(241,2%,89%)","hsl(241,2%,89%)","hsl(83,59%,17%)","hsl(53,14%,38%)","hsl(241,2%,89%)","hsl(295,44%,19%)","hsl(241,2%,89%)","hsl(83,59%,17%)","hsl(127,4%,47%)","hsl(241,2%,89%)","hsl(241,2%,89%)"],
    // red + cyan
    ["hsl(133,96%,81%)","hsl(32,62%,50%)","hsl(14,86%,51%)","hsl(7,81%,41%)","hsl(198,79%,50%)","hsl(24,98%,38%)","hsl(15,83%,83%)","hsl(259,40%,92%)","hsl(14,86%,51%)","hsl(341,82%,50%)"],
    // pale purple
    ["hsl(205,3%,96%)","hsl(205,3%,96%)","hsl(205,94%,48%)","hsl(205,3%,96%)","hsl(138,46%,34%)","hsl(282,82%,68%)","hsl(247,97%,63%)","hsl(350,32%,42%)","hsl(125,8%,51%)","hsl(205,3%,96%)","hsl(282,82%,68%)","hsl(350,32%,42%)","hsl(149,85%,99%)"],
    // dark brown
    ["hsl(34,74%,54%)","hsl(160,58%,4%)","hsl(34,74%,54%)","hsl(143,76%,30%)","hsl(22,73%,19%)","hsl(22,73%,19%)","hsl(22,73%,19%)","hsl(329,66%,6%)","hsl(22,73%,19%)","hsl(242,28%,44%)"],
    // blue + brown
    ["hsl(178,93%,49%)","hsl(270,97%,39%)","hsl(192,83%,59%)","hsl(346,58%,41%)","hsl(42,68%,40%)","hsl(223,90%,49%)","hsl(178,93%,49%)"],
    // blue + cyan
    ["hsl(179,88%,51%)","hsl(192,95%,33%)","hsl(212,97%,43%)","hsl(271,87%,32%)","hsl(271,87%,32%)","hsl(212,97%,43%)","hsl(65,91%,96%)","hsl(271,87%,32%)","hsl(212,97%,43%)","hsl(354,54%,48%)","hsl(111,73%,76%)","hsl(179,88%,51%)","hsl(98,75%,70%)","hsl(212,97%,43%)"],
    // chameleon
    ["hsl(344,30%,51%)","hsl(76,99%,86%)","hsl(76,99%,86%)","hsl(222,64%,64%)","hsl(153,65%,42%)","hsl(222,64%,64%)","hsl(148,40%,50%)","hsl(13,93%,50%)","hsl(340,43%,51%)","hsl(76,99%,86%)"],
    // kaleidoscope
    ["hsl(209,68%,50%)","hsl(305,77%,27%)","hsl(317,98%,46%)","hsl(305,77%,27%)","hsl(232,57%,26%)","hsl(31,98%,49%)","hsl(271,94%,53%)","hsl(163,55%,47%)","#ffffff","hsl(271,94%,53%)","hsl(186,82%,51%)","hsl(75,86%,48%)","hsl(147,78%,76%)","hsl(224,70%,23%)","#ffffff"],
    // pastel + black
    ["hsl(181,52%,55%)","hsl(49,100%,2%)","hsl(151,77%,33%)","hsl(20,80%,50%)","hsl(215,88%,65%)","hsl(114,74%,84%)","hsl(319,56%,37%)","hsl(349,97%,93%)","hsl(112,75%,82%)","hsl(251,84%,87%)","hsl(29,89%,67%)","hsl(47,79%,89%)","hsl(200,94%,17%)","hsl(212,44%,39%)"],
    // purple + red (better for animation with higher resolutions)
    ["hsl(51,81%,66%)","hsl(15,69%,21%)","hsl(300,99%,50%)","hsl(51,81%,66%)","hsl(172,80%,70%)","hsl(172,80%,70%)","hsl(6,92%,49%)","hsl(259,89%,50%)","hsl(269,77%,44%)","hsl(269,77%,44%)","hsl(356,64%,50%)","hsl(9,73%,50%)","hsl(215,94%,49%)","hsl(215,94%,49%)","hsl(259,89%,50%)"],
    // ivory + many colors
    ["hsl(337,97%,34%)","hsl(3,63%,88%)","hsl(83,68%,30%)","hsl(230,63%,99%)","hsl(348,33%,64%)","hsl(248,55%,50%)","hsl(329,89%,47%)","hsl(20,99%,42%)","hsl(90,75%,54%)","hsl(29,96%,92%)","hsl(230,63%,99%)","hsl(218,85%,54%)","hsl(29,96%,92%)","hsl(3,63%,88%)","hsl(196,94%,82%)"],
    // too many colors
    ["hsl(217,56%,22%)","hsl(217,56%,22%)","hsl(255,99%,49%)","hsl(164,28%,10%)","hsl(141,96%,41%)","hsl(43,75%,63%)","hsl(256,19%,50%)","hsl(88,84%,40%)","hsl(335,81%,50%)","hsl(295,60%,47%)","hsl(318,13%,53%)","hsl(90,27%,66%)","hsl(32,63%,90%)","hsl(30,71%,77%)","hsl(32,63%,90%)","hsl(177,48%,50%)"],
    // yellow + brown
    ["hsl(72,85%,76%)","hsl(5,60%,44%)","hsl(72,85%,76%)","hsl(72,85%,76%)","hsl(5,60%,44%)","hsl(72,85%,76%)","hsl(72,85%,76%)","hsl(5,60%,44%)","hsl(72,85%,76%)","hsl(72,85%,76%)"],
    // green + purple
    ["hsl(176,97%,16%)","hsl(299,35%,51%)","hsl(20,66%,83%)","hsl(127,64%,50%)","hsl(127,64%,50%)","hsl(299,35%,51%)","hsl(58,87%,54%)","hsl(127,64%,50%)","hsl(176,97%,16%)"],
    // brown + green
    ["hsl(126,71%,94%)","hsl(126,71%,94%)","hsl(358,39%,49%)","hsl(39,82%,53%)","hsl(300,32%,50%)","hsl(193,66%,24%)","hsl(225,78%,21%)","hsl(358,39%,49%)","hsl(39,82%,53%)","hsl(39,82%,53%)","hsl(67,12%,44%)","hsl(225,78%,21%)","hsl(130,49%,50%)","hsl(225,78%,21%)","hsl(358,39%,49%)","hsl(130,49%,50%)"],
    // brown + purple
    ["hsl(334,75%,5%)","hsl(261,70%,33%)","hsl(33,92%,62%)","hsl(288,43%,29%)","hsl(33,92%,62%)","hsl(334,75%,5%)","hsl(57,91%,86%)","hsl(57,91%,86%)","hsl(334,75%,5%)"],
    // light purple + BW
    ["hsl(238,88%,67%)","hsl(183,71%,95%)","hsl(238,88%,67%)","hsl(201,53%,2%)","hsl(346,95%,48%)","hsl(51,48%,96%)","hsl(301,19%,59%)","hsl(43,80%,82%)","hsl(57,86%,17%)","hsl(183,71%,95%)","hsl(51,48%,96%)","hsl(57,86%,17%)","hsl(238,88%,67%)","hsl(57,86%,17%)","hsl(51,48%,96%)","hsl(201,53%,2%)"],
    // green + white
    ["hsl(68,98%,9%)","hsl(283,67%,100%)","hsl(115,82%,40%)","hsl(215,42%,27%)","hsl(215,42%,27%)","hsl(167,100%,100%)","hsl(18,95%,75%)","hsl(68,98%,9%)","hsl(215,42%,27%)","hsl(231,91%,96%)","hsl(133,68%,65%)","hsl(115,82%,40%)","hsl(283,67%,100%)","hsl(167,100%,100%)","hsl(283,67%,100%)","hsl(167,100%,100%)"],
    // garden
    ["hsl(93,73%,52%)","hsl(152,40%,34%)","hsl(262,76%,82%)","hsl(152,40%,34%)","hsl(42,99%,23%)","hsl(246,15%,48%)","hsl(152,40%,34%)","hsl(291,90%,97%)","hsl(291,90%,97%)","hsl(291,90%,97%)","hsl(262,76%,82%)","hsl(262,76%,82%)","hsl(93,73%,52%)","hsl(175,34%,15%)","hsl(42,99%,23%)","hsl(349,91%,76%)"],
    // pink + light yellow
    ["hsl(309,8%,96%)","hsl(323,59%,50%)","hsl(76,91%,77%)","hsl(323,59%,50%)","hsl(323,59%,50%)","hsl(309,8%,96%)","hsl(323,59%,50%)","hsl(309,8%,96%)","hsl(340,12%,80%)"],
    // emerald + pink
    ["hsl(171,99%,42%)","hsl(312,99%,73%)","hsl(64,13%,14%)","hsl(64,13%,14%)","hsl(64,13%,14%)","hsl(216,98%,45%)","hsl(48,93%,87%)","hsl(351,56%,33%)","hsl(207,82%,72%)"],
    // pale purple + white
    ["hsl(35,32%,29%)","hsl(36,81%,70%)","hsl(57,96%,37%)","hsl(324,89%,1%)","hsl(215,38%,42%)","hsl(264,59%,49%)","hsl(270,52%,96%)","hsl(215,38%,42%)","hsl(270,52%,96%)","hsl(270,52%,96%)","hsl(270,52%,96%)","hsl(29,88%,25%)","hsl(264,59%,49%)","hsl(270,52%,96%)","hsl(270,52%,96%)"],
    // purple + green
    ["hsl(286,75%,6%)","hsl(28,45%,86%)","hsl(1,67%,77%)","hsl(6,76%,47%)","hsl(166,46%,94%)","hsl(166,46%,94%)","hsl(130,91%,23%)","hsl(282,82%,46%)","hsl(166,46%,94%)"],
    // cyan + purple
    ["hsl(322,95%,16%)","hsl(196,41%,81%)","hsl(350,97%,32%)","hsl(248,21%,2%)","hsl(205,83%,79%)","hsl(81,80%,86%)","hsl(81,80%,86%)","#2a41b7","hsl(287,91%,53%)","hsl(181,83%,57%)"],
    // brick
    ["hsl(356,73%,44%)","hsl(249,90%,88%)","#223f26","hsl(35,78%,56%)","hsl(242,70%,96%)"],
    // green + red
    ["hsl(15,97%,87%)","hsl(95,78%,50%)","hsl(181,89%,6%)","hsl(192,89%,18%)","#ffffff","#ffffff","#ffffff","hsl(315,40%,56%)","hsl(161,75%,62%)","hsl(344,64%,54%)","hsl(261,82%,45%)","hsl(9,55%,6%)","hsl(177,66%,57%)","hsl(90,78%,24%)","hsl(13,72%,46%)"],
    // red + blue
    ["hsl(356,38%,50%)","hsl(327,64%,50%)","hsl(235,69%,59%)","hsl(51,46%,72%)","hsl(10,95%,50%)","#ffffff","#ffffff","hsl(255,47%,47%)","hsl(192,35%,93%)","hsl(65,99%,50%)","hsl(51,46%,72%)","hsl(356,38%,50%)","hsl(192,35%,93%)"],
    // orange + cyan
    ["hsl(84,14%,71%)","hsl(204,79%,35%)","hsl(23,86%,48%)","hsl(205,85%,96%)","hsl(170,86%,66%)","hsl(334,70%,61%)","hsl(244,17%,86%)","hsl(285,12%,69%)","hsl(29,91%,57%)","hsl(144,29%,89%)","hsl(196,55%,8%)","hsl(8,44%,48%)","hsl(277,51%,35%)","hsl(209,83%,50%)","hsl(85,37%,91%)","hsl(29,91%,57%)"],
    // yellow + purple
    ["hsl(291,43%,48%)","hsl(34,99%,52%)","hsl(295,36%,76%)","#f0e80f","hsl(57,88%,98%)","#f0e80f","#f0e80f","hsl(41,50%,57%)","hsl(198,92%,43%)","hsl(349,99%,45%)","hsl(291,43%,48%)","hsl(266,78%,63%)","hsl(57,88%,98%)","hsl(278,85%,38%)","hsl(278,85%,38%)","hsl(295,36%,76%)"],
    // yet another green + orange
    ["hsl(98,59%,16%)","hsl(162,69%,39%)","hsl(162,69%,39%)","hsl(38,85%,57%)","hsl(185,74%,88%)","hsl(162,69%,39%)","hsl(98,59%,16%)","hsl(228,45%,84%)","hsl(5,97%,3%)","hsl(185,74%,88%)","hsl(269,71%,30%)"],
    // pale blue + orange
    ["hsl(155,52%,85%)","hsl(155,52%,85%)","hsl(129,88%,6%)","hsl(262,96%,49%)","hsl(35,82%,60%)","hsl(238,52%,38%)","hsl(28,79%,48%)","hsl(28,79%,48%)","hsl(87,85%,14%)","hsl(155,52%,85%)","hsl(155,52%,85%)"],
    // many colors
    ["hsl(96,80%,91%)","hsl(14,87%,52%)","hsl(133,63%,77%)","hsl(342,50%,1%)","hsl(133,63%,77%)","hsl(240,76%,60%)","hsl(299,86%,14%)","hsl(47,97%,45%)","hsl(259,99%,49%)","hsl(65,91%,65%)","hsl(14,87%,52%)","hsl(96,80%,91%)","hsl(151,95%,14%)","hsl(280,81%,54%)"],
    // blue carpet
    ["#52959b","#1c4644","#2a575a","#fdfdfd","#c5b7ac","#232524","#b2bdaf","#4a575f","#2e6770","#f7f7f7","#5b544a","#1f5b63","#166874","#34a6b0","#c0ced1","#e1cbb6"],
    // gray carpet
    ["#4b4b3f","#422b19","#855b45","#071619","#ece3da","#b3a78f","#456071","#393a3c","#eae7e2","#9ba49f","#f9f6ef","#476d70","#e7e4dd","#e6e1db","#46646c","#20332f"],
    // red carpet
    ["#472f3c","#f9feff","#b86766","#b73d3a","#feffff","#b83f37","#8f7274","#2b1d1a","#2e272e","#d75e56","#ffffff","#eef0eb","#9d4f67","#c53d3d","#ffffff","#feffff"],
    // sepia
    ["#9d8875","#272621","#674140","#93806f","#2b2f30","#d5d8e1","#dddbcf","#d4c0a5","#310f10","#fff6de","#e9e2da","#acaca4","#a8a59c","#674043","#dbd3d1","#f9fcff"],
    // purple, red, yellow
    ["hsl(260,34%,59%)","hsl(71,93%,98%)","hsl(16,98%,87%)","hsl(260,34%,59%)","hsl(334,89%,35%)","hsl(234,86%,43%)","hsl(17,81%,46%)","hsl(281,61%,51%)","hsl(71,93%,98%)","hsl(56,91%,49%)","hsl(71,93%,98%)","hsl(234,86%,43%)","hsl(68,89%,73%)","hsl(333,96%,79%)","hsl(260,34%,59%)"],
    // red green firework
    ["#6e739b","#84226f","#0b0000","#110300","#52171d","#3f9c4b","#1e1212","#080002","#160000","#f03560","#85e583","#130006","#b2ffcd","#150921","#a9cf7c","#09061b","#0b0000","#0a0100"],
    // red firework
    ["#ff5f66","#9b3184","#00004e","#030627","#060002","#000000","#050126","#140107","#000045","#2d0000","#64110b","#0d0000","#03001b","#fdec96","#010119","#0c0000","#1f010b","#00001a","#000100","#c83f39","#e15c4d","#580000","#1c0004","#000000","#cc3d35"],
    // pink yellow firework
    ["#a46075","#020202","#807a7c","#000000","#836a63","#020100","#000000","#010000","#5c211b","#4d241e","#160000","#ef8ab4","#6b2700","#000000","#000000","#a87861","#390000","#130e14","#000000","#f8f2c0","#61642b","#0b0003","#190101","#000000"],
    // stone
    ["#091113","#405238","#e7be8a","#baf3ff","#cfb079","#1d2f3d","#77aecd"],
    // needlework
    ["#e4eadd","#d6dad4","#d5d9ce","#a2a481","#4a714e","#a94327","#dde0d8","#a33c18","#eaecdd","#8a8d6a","#e3ceb0","#c5d1c8"],
    // blue + orange
    ["hsl(36,99%,61%)","hsl(232,84%,35%)","hsl(359,74%,85%)","hsl(36,99%,61%)","hsl(229,81%,68%)","hsl(82,95%,91%)","hsl(351,46%,32%)","hsl(36,99%,61%)","hsl(34,88%,28%)","hsl(248,98%,49%)","hsl(82,95%,91%)","hsl(188,100%,80%)"],
    // rgb + white
    ["hsl(25,67%,93%)","hsl(231,63%,12%)","hsl(25,67%,93%)","hsl(228,72%,98%)","hsl(307,74%,17%)","hsl(266,81%,43%)","hsl(221,93%,68%)","hsl(148,60%,78%)","hsl(93,63%,41%)","hsl(345,96%,50%)","hsl(6,73%,99%)","hsl(223,56%,49%)","hsl(333,54%,94%)","hsl(329,96%,59%)"],
    // sparse red + blue
    ["hsl(352,89%,51%)","hsl(95,93%,90%)","hsl(95,93%,90%)","hsl(97,71%,84%)","hsl(219,99%,39%)","hsl(48,30%,91%)","hsl(302,8%,97%)","hsl(95,93%,90%)","hsl(219,99%,39%)","hsl(97,71%,84%)"],
    // toukae
    ["#020200","#010300","#341b16","#fafaf2","#010101","#b27936","#000000","#000201","#ff5d42","#080500","#7f5322","#301e06","#020100","#fcffed","#070601","#030200","#825329"],
    // sparse white and red
    ["black", "black", "black", "black", "black", "black", "black", "black", "black", "black", "black", "#ff5e3f","#fefce7"],
    // orange + gray
    ["#97b8e2","#15264e","#0e1832","#040203","#162243","#feb451","#0e1e44","#21355e","#a7a7b9","#fea330","#0b0707","#0c0d1a","#fceebc","#fde49f","#110d0e","#213968","#0e1e44","#0e1a3b","#df822c","#84a8d6"],
    // another orange + gray,
    ["#0a122f","#151f38","#3b2a28","#dc8536","#1e2743","#324266","#3c394c","#644c4d","#97b8e2","#97b8e2","#162243","#8e502c","#8fb2de","#e9975f","#031439","#2f2a38","#d87500","#0b0504","#fcf3cc","#832900"],
    // dark brown
    ["#171613","#f0c682","#6e4418","#1a1106","#231403","#433728","#6c5f4d","#f6cd88","#c89963"],
    // many colors + black
    ["hsl(199,40%,52%)","hsl(143,83%,9%)","hsl(253,91%,44%)","hsl(132,79%,4%)","hsl(355,90%,48%)","hsl(27,60%,74%)","hsl(111,78%,37%)","hsl(287,46%,33%)","hsl(304,77%,9%)","hsl(123,33%,26%)","hsl(106,86%,3%)","hsl(253,91%,44%)","hsl(205,73%,98%)","hsl(132,79%,4%)","hsl(69,42%,20%)"],
    // green + orange
    ["hsl(190,87%,28%)","hsl(38,82%,46%)","hsl(351,95%,49%)","hsl(149,71%,97%)","hsl(68,86%,46%)","hsl(35,53%,47%)","hsl(149,71%,97%)"],
  ];
  const defaultColorTable = colorTableList[0].slice();
  
  // state
  let mainCoef = defaultCoef;
  let colorTable = defaultColorTable;
  let useGPU = false;
  let galleryPictureSize = galleryPictureSizeSML[0];
  let autoTimer = null;
  
  // init
  let mainCanvas, internalCanvas, pastedImageCanvas;
  const updateDownloadLink = downloadLinkUpdater();
  const [smallGallery, mediumGallery, largeGallery] =
    galleryPictureSizeSML.map(size => () => setGallerySize(size));
  readURL();
  updateCanvas();
  updateCoefForm();
  showDefaultGallery();
  initializeUI();
  update();
  !location.search && startAuto();
  
  // main
  function update(isNewSetting) {
    isNewSetting && updateCanvas();
    normalizeMainCoef();
    draw(mainCoef);
    updateGallery();
  }
  function draw(coef, ctable, canvas, unit) {
    const cv = canvas || mainCanvas;
    const args = [coef, ctable || colorTable, cv, unit || mainUnit];
    const usingGPU = drawGPU(...args) || drawCPU(...args);
    if (cv !== mainCanvas) {return;}
    Q('#state').innerText = usingGPU ? '(GPU) ' : '';
    updateDownloadLink();
  }
  
  // draw
  function drawCPU(coef, ctable, canvas, unit) {
    const g = canvas.getContext('2d');
    const center = Math.floor(resolution / 2);
    function sqr(k) {return k * k;}
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        const k = Math.floor(coef * (sqr(i - center) + sqr(j - center)));
        const style = ctable[k % ctable.length];
        fillSquare(g, i * unit, j * unit, unit, style);
      }
    }
    return false;
  }
  function drawGPU(coef, ctable, canvas, unit) {
    if (!useGPU || !isTwglAvailable()) {return false;}
    const gl = canvas.getContext('webgl');
    if (!gl) {return false;}
    const shaders = ['vertex_shader', 'fragment_shader'];
    const programInfo = twgl.createProgramInfo(gl, shaders);
    const arrays = {position: {numComponents: 2, data: [-1,-1, 1,-1, -1,1, 1,1]}};
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
    const cvec = getColorVectors(ctable);
    // dummy texture to use colorTable in GPU
    const src = cvec.flat(), numColors = cvec.length;
    const colorTexture = twgl.createTexture(gl, {src, width: numColors, height: 1})
    const uniforms = {resolution, unit, coef, numColors, colorTexture};
    gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    twgl.setUniforms(programInfo, uniforms);
    twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLE_STRIP);
    return true;
  }
  function isTwglAvailable() {return typeof twgl !== 'undefined';}
  
  // drag
  function setMouseActions(canvas) {
    let prevPoint = null;
    canvas.onmousedown = e => {prevPoint = mouseEventPoint(e);}
    canvas.onmouseleave = document.onmouseup = e => {prevPoint = null;}
    canvas.onmousemove = e => {
      if (!prevPoint) {return;}
      const point = mouseEventPoint(e);
      const [dx, dy] = [point.x - prevPoint.x, - (point.y - prevPoint.y)];
      const horizontal = Math.abs(dx) > Math.abs(dy);
      addCoef(horizontal ? dx * horizontalDragStep : dy * verticalDragStep);
      prevPoint = point;
    }
    canvas.onwheel = e => {e.preventDefault(); addCoef(e.deltaY * wheelStep);}
    setSwipeActions(canvas);
  }
  function mouseEventPoint(e) {return {x: e.clientX, y: e.clientY};}
  
  // swipe
  function setSwipeActions(canvas) {
    // accept swipe only after double tap
    let swipable = false, lastTap = null;
    const touchEquiv = [
      // [ontouchXXX, onmouseXXX, preProc, postProc]
      ['start', 'down', startTouch, null],
      ['move', 'move', null, null],
      ['end', 'leave', null, endTouch],
      ['cancel', 'leave', null, endTouch],
    ];
    touchEquiv.forEach(([touchName, mouseName, preProc, postProc]) => {
      function maybe(f, ...a) {f && f(...a);}
      canvas['ontouch' + touchName] = e => {
        const t = e.changedTouches[0];  // ignore multi-touch
        if (!t) {return;}
        maybe(preProc, t);
        if (!swipable) {return;}
        canvas['onmouse' + mouseName](t);
        e.preventDefault();
        maybe(postProc);
      }
    });
    // detect double tap
    function startTouch(e) {
      if (swipable) {return;}
      const time = Date.now(), point = mouseEventPoint(e);
      const immediate = lastTap && (time - lastTap.time <= doubleTapMillisec);
      const isDoubleTap = immediate && near(point, lastTap.point);
      const isNewTap = !isDoubleTap;
      swipable = isDoubleTap;
      lastTap = isNewTap && {time, point};
      isNewTap ? showDoubleTapHint() : cancelDoubleTapHint();
    }
    function endTouch() {swipable = false;}
    function near(a, b) {
      function near1(key) {return Math.abs(a[key] - b[key]) <= doubleTapDistance;}
      return ['x', 'y'].every(near1);
    }
    // show hint
    let doubleTapHintTimer = null;
    function showDoubleTapHint() {
      const show = () => toast('Double Tap & Swipe!');
      cancelDoubleTapHint();
      doubleTapHintTimer = setTimeout(show, doubleTapMillisec * 1.1);
    }
    function cancelDoubleTapHint() {clearTimeout(doubleTapHintTimer);}
  }
  
  // keyboard
  document.onkeydown = e => {
    const isStopped = stopAuto();
    if (e.target.tagName === 'INPUT') {return;}
    // allow auto-repeat
    switch (e.key) {
    case '<': addCoef(- kbdFastStep); return;
    case '>': addCoef(+ kbdFastStep); return;
    case ',': addCoef(- kbdSlowStep); return;
    case '.': addCoef(+ kbdSlowStep); return;
    case '[': addCoef(- kbdFineStep); return;
    case ']': addCoef(+ kbdFineStep); return;
    case '(': prevGallery(); return;
    case ')': nextGallery(); return;
    }
    // ignore auto-repeat
    if (e.repeat) {return;}
    switch (e.key) {
    case 'c': !e.ctrlKey && copyCoef(); return;
    case 'a': !isStopped && startAuto(); return;
    case 'f': toggleFullScreen(); return;
    case 'z': rotateGallerySize(); return;
    case 'R': rotateResolution(); return;
    case 'x': case 'X': exitFullScreen(() => showPresetColorVariations(e)); return;
    case 'V': exitFullScreen(showDefaultMixedVariations); return;
    case 'g': scrollToTop(); return;
    case 'm': scrollToMid(); return;
    case 'G': e.ctrlKey ? (toggleGPU(), e.preventDefault()) : scrollToBot(); return;
    }
  }
  
  // color table
  function randomColorTable() {
    const r = Math.random(), n = rand(maxRandomColors - 1) + 2;
    const randColor = randColorGenerator();
    let c = randColor();
    function generateColor() {Math.random() < r && (c = randColor()); return c;}
    const a = [...Array(n)].map(generateColor);
    const isSingleColor = a.every(z => z === a[0]);
    return isSingleColor ? randomColorTable() : shuffle(a);
  }
  function randomlyReplacedColorTable(ctable) {
    const randColor = randColorGenerator();
    const oldColor = uniq(ctable);
    const newColor = oldColor.map(randColor);
    return ctable.map(c => newColor[oldColor.indexOf(c)]);
  }
  function setColorTable(table) {
    if (!isValidColorTable(table)) {
      toast(`invalid color table: ${JSON.stringify(table)}`);
      return;
    }
    colorTable = table.slice();
    update(true);
    updateURL();
    updateColorEditor();
  }
  function showColorTable() {
    const container = Q('#palette');
    container.innerHTML = '';
    colorTable.forEach(c => {
      const t = document.createElement('div');
      t.classList.add('tooltip-origin');
      const elem = document.createElement('span');
      elem.style.backgroundColor = c;
      elem.dataset.tooltip = c;
      elem.innerHTML = '&nbsp;';
      container.appendChild(t);
      t.appendChild(elem);
    });
    Q('#paletteColorNum').innerText = uniq(colorTable).length;
  }
  /* function encodeColorTable(a) {return a.join('_');} */
  /* function decodeColorTable(s) {return s.split('_');} */
  function encodeColorTable(a) {return JSON.stringify(a);}
  function decodeColorTable(s, failed) {
    try {return JSON.parse(s);} catch {return failed;}
  }
  function isValidColorTable(ctable) {
    return Array.isArray(ctable) && ctable.length > 1 &&
      ctable.every(s => typeof s === 'string');
  }
  function isSameColorTable(ctable1, ctable2) {
    const [s1, s2] = [ctable1, ctable2].map(encodeColorTable);
    return (s1 === s2);
  }
  
  // color editor
  let oldColorTable;
  Q('#groupwise').onchange = updateColorEditor;
  function showColorEditor() {
    updateColorEditor();
    Q('#colorEditor').hidden = false;
    Q('#showColorEditor').disabled = true;
  }
  function finishColorEditor(newColorTable) {
    setColorTable(newColorTable);
    Q('#colorEditor').hidden = true;
    Q('#showColorEditor').disabled = false;
  }
  function acceptColorEditor() {finishColorEditor(colorTable);}
  function cancelColorEditor() {finishColorEditor(oldColorTable);}
  function updateColorEditor() {
    oldColorTable = colorTable.slice();
    const initVal = normalizeColorTable(colorTable);
    const container = Q('#colorPickerContainer');
    container.innerHTML = '';
    function addPickers(a, setter) {
      a.forEach((c, k) => container.appendChild(colorPicker(c, k, setter)));
    }
    function addPickersIndividually() {
      addPickers(initVal, (k, v) => (colorTable[k] = v));
    }
    function addPickersGroupwise() {
      const uniqueColor = uniq(initVal);
      const group = uniqueColor.map(c => indicesOf(c, initVal));
      const setter = (k, v) => group[k].forEach(j => colorTable[j] = v);
      addPickers(uniqueColor, setter);
    }
    Q('#groupwise').checked ? addPickersGroupwise() : addPickersIndividually();
  }
  function colorPicker(initialValue, index, setter) {
    const p = document.createElement('input');
    p.type = 'color';
    p.value = initialValue;
    p.oninput = _ => {setter(index, p.value); update();};
    return p;
  }
  function normalizeColorTable(ctable) {
    return getColorVectors(colorTable).map(toRGB);
  }
  function copyColorTable() {
    copyToClipboard(encodeColorTable(colorTable));
    setColorTable(colorTable); // to show color table as side effect
  }
  function pasteColorTable(e) {
    const elem = e.target, text = elem.value;
    const ctable = decodeColorTable(text);
    ctable ? (setColorTable(ctable), scrollToTop()) :
      toast(`Invalid color table: ${text}`);
    elem.value = '';
    elem.blur();
  }
  Q('#pasteColorTable').oninput = pasteColorTable;
  
  // auto
  function startAuto() {
    cancelAuto();
    const step = Math.pow(2, toNum(Q('#speed').value)) * autoStep;
    autoTimer = setTimeout(() => {addCoef(step); startAuto();}, autoMillisec);
    Q('#startAuto').hidden = true;
    updateAutoButtons(true);
  }
  function stopAuto() {
    const isStopped = !!autoTimer;
    cancelAuto();
    updateAutoButtons(false);
    return isStopped;
  }
  function cancelAuto() {
    autoTimer && clearTimeout(autoTimer);
    autoTimer = null;
  }
  function updateAutoButtons(isStarted) {
    Q('#startAuto').hidden = isStarted;
    Q('#stopAuto').hidden = !isStarted;
  }
  function updateAutoSpeed() {
    Q('#speedVal').innerText = Q('#speed').value.padStart(2, '0');
    autoTimer && startAuto();
  }
  
  // UI parts
  const keepAuto = ['startAuto', 'fullScreen'];
  function initializeUI() {
    initializeButtons();
    initializeSliders();
    function stopAutoMaybe(e) {
      !keepAuto.includes(e.target.id) && (e.target.type !== 'range') && stopAuto();
    }
    document.addEventListener('click', stopAutoMaybe);
    window.onpopstate = e => {readURL(); update(true);};
    merge(Q('#coef'), {
      oninput: setCoefByForm,
      onkeydown: e => {e.key === 'Enter' && (e.target.blur(), updateCoefForm());},
    });
    updateBlur();
    updateAutoSpeed();
  }
  function initializeButtons() {
    // assume "id in HTML" = "function name in JS"
    const buttonAction = {
      copyURL, newTab, nextGallery, prevGallery, startAuto, stopAuto,
      copyCoef, fullScreen,
      smallGallery, mediumGallery, largeGallery,
      copyColorTable,
      showDefaultGallery, showCoefVariations, showColorVariations, showAltVariations,
      showPresetColorVariations, showDefaultMixedVariations,
      showPresetColorVariationsSimply,
      showColorEditor, acceptColorEditor, cancelColorEditor,
      pickColors,
    }
    function setAction(id, action){Q('#' + id).onclick = action;}
    eachKeyValue(buttonAction, setAction);
  }
  function initializeSliders() {
    const sliderTable = [
      // id, value, oninput
      ['blur', defaultBlur, updateBlur],
      ['speed', defaultAutoSpeed, updateAutoSpeed],
    ];
    function setup([id, value, oninput]) {merge(Q('#' + id), {value, oninput});}
    sliderTable.forEach(setup);
  }
  function setGallerySize(size) {
    galleryPictureSize = size;
    updateGallery();
  }
  function rotateGallerySize() {
    setGallerySize(rotate(galleryPictureSize, galleryPictureSizeSML));
  }
  function updateBlur() {
    const b = Q('#blur').value;
    mainCanvas.style.filter = `blur(${b}vmin)`;
    Q('#blurVal').innerText = toNum(b).toFixed(blurDigits);
  }
  function downloadLinkUpdater() {
    function updateNow() {
      const href = mainCanvas.toDataURL('image/png');
      const download = `tapestry${encodeCoef(mainCoef)}.png`;
      merge(Q('#download'), {href, download, hidden: false});
    }
    const updateLater = deferredProc(updateNow, downloadLinkDelayMillisec);
    function f() {Q('#download').hidden = true; updateLater();}
    return f;
  }
  function toggleGPU() {
    if (!isTwglAvailable()) {toast('Missing TWGL.js'); return;}
    useGPU = !useGPU;
    removeMainCanvas(); // force reset
    internalCanvas = null; // force reset
    update(true);
    updateURL();
    toast(useGPU ? 'GPU' : 'CPU');
  }
  
  // fullscreen
  function fullScreen() {mainCanvas.requestFullscreen();}
  function toggleFullScreen() {exitFullScreen() || fullScreen();}
  function exitFullScreen(proc) {
    const exited = document.fullscreenElement && document.exitFullscreen();
    proc && (exited ? exited.then(() => setTimeout(proc, 100)) : proc());
    return exited;
  }
  
  // clipboard
  function copyURL() {updateURL(); copyToClipboard(location.href);}
  function copyToClipboard(text) {
    updateURL();
    navigator.clipboard.writeText(text);
    toast(text);
  }
  
  // coef
  function setCoef(newCoef, byForm) {
    mainCoef = newCoef;
    update();
    !byForm && updateCoefForm();
  }
  function addCoef(d) {setCoef(mainCoef + d);}
  function normalizeMainCoef() {mainCoef = normalizeCoef(mainCoef);}
  function normalizeCoef(coef, max) {
    function digitizeCoef(num) {return decodeCoef(encodeCoef(num))}
    const int = Math.floor(coef), frac = coef - int;
    return digitizeCoef(positiveMod(int, max || colorTable.length) + frac);
  }
  function encodeCoef(num) {return num.toFixed(coefURLDigits);}
  function decodeCoef(str) {return toNum(str);}
  function updateCoefForm() {
    const form = Q('#coef'), val = encodeCoef(mainCoef);
    form.value = val.includes('.') ? val.replace(/0+$/, '').replace(/[.]$/, '') : val;
    form.dataset.valid = 'yes';
  }
  function setCoefByForm() {
    const form = Q('#coef'), v = form.value, c = toNum(v);
    const valid = v.match(/^\d+[.]?\d*$/) && !Number.isNaN(c);
    form.dataset.valid = valid ? 'yes' : 'no'
    valid && setCoef(c, true);
  }
  function copyCoef() {copyToClipboard(encodeCoef(mainCoef));}
  function randCoef(max) {
    const m = max || colorTable.length;
    return normalizeCoef(Math.random() * m, m);
  }
  
  // canvas
  function replaceCanvasMaybe(canvas, unit, pictureSize) {
    // for GPU
    const w = expectedCanvasWidth(unit);
    const resized = !canvas || (canvas.width !== w);
    if (!resized) {return canvas;}
    canvas && canvas.remove();
    const newCanvas = document.createElement('canvas');
    setCanvasSize(newCanvas, unit, pictureSize);
    return newCanvas;
  }
  function updateInternalCanvas() {
    internalCanvas = replaceCanvasMaybe(internalCanvas, galleryUnit, galleryPictureSize);
  }
  function updateMainCanvas() {
    const oldCanvas = mainCanvas;
    mainCanvas = replaceCanvasMaybe(oldCanvas, mainUnit, mainPictureSize);
    if (mainCanvas === oldCanvas) {return;}
    mainCanvas.id = 'mainCanvas';
    Q('#mainCanvasContainer').appendChild(mainCanvas);
  }
  function updateCanvas() {
    updateMainCanvas();
    updateInternalCanvas();
    Q('#mod').innerText = colorTable.length;
    showColorTable();
    setMouseActions(mainCanvas);
    updateBlur();
  }
  function removeMainCanvas() {
    mainCanvas && mainCanvas.remove();
    mainCanvas = null;
  }
  function setCanvasSize(canvas, unit, pictureSize) {
    canvas.width = canvas.height = expectedCanvasWidth(unit);
    canvas.style.width = canvas.style.height = pictureSize;
  }
  function expectedCanvasWidth(unit) {return resolution * unit;}
  
  // graphics
  function fillSquare(g, x, y, size, style) {
    g.fillStyle = style;
    g.beginPath(); g.rect(x, y, size, size); g.fill();
  }
  function getColorVectors(colors) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 1;
    const ctx = canvas.getContext('2d');
    function rgbaVec(colorString) {
      fillSquare(ctx, 0, 0, 1, colorString);
      return [...ctx.getImageData(0, 0, 1, 1).data];
    }
    return colors.map(rgbaVec);
  }
  
  // URL
  function readURL() {
    colorTable = defaultColorTable;
    new URLSearchParams(location.search).forEach((value, key) => {
      switch (key) {
      case 'c': mainCoef = decodeCoef(value); break;
      case 'GPU': useGPU = true; break;
      case 'palette': colorTable = decodeColorTable(value, defaultColorTable); break;
      }
    })
  }
  function updateURL() {
    const url = generateURL(mainCoef);
    url !== location.href && history.pushState(null, document.title, url);
  }
  function newTab() {
    updateURL();
    window.open(generateURL(mainCoef), '_blank');
  }
  function generateURL(coef, optionColorTable) {
    const url = new URL(location.toString());
    const params = new URLSearchParams('');
    params.append('c', encodeCoef(coef));
    useGPU && params.append('GPU', 'y');
    const ctab = optionColorTable || colorTable;
    const [ct, dct] = [ctab, defaultColorTable].map(encodeColorTable);
    ct && ct !== dct && params.append('palette', ct);
    url.search = params.toString();
    return url.toString();
  }
  
  // gallery
  function showDefaultGallery(e) {
    const keepPosition = !e;
    const note = `These ${galleryCoef.length} patterns are generated from just one parameter c without randomness.`;
    showGallery(galleryCoef.map(c => [c, defaultColorTable]), note, keepPosition, true);
  }
  function isDefaultColorAndGallery() {
    const isDefaultGallery = Q('#showDefaultGallery').disabled; // fixme!
    return isDefaultGallery && isSameColorTable(colorTable, defaultColorTable);
  }
  function showGallery(ary, note, keepPosition, isDefaultGallery) {
    Q('#showDefaultGallery').disabled = isDefaultGallery;
    Q('#galleryNote').innerText = note || '';
    const gallery = Q('#gallery');
    gallery.innerHTML = '';
    ary.forEach(([c0, ct], k) => {
      const c = normalizeCoef(c0);
      const ctIndex = colorTableList.findIndex(t => isSameColorTable(t, ct));
      const ctTooltip = ctIndex >= 0 ? ` #${ctIndex}` : ''
      const tooltip = `c=${encodeCoef(c)} (${uniq(ct).length}/${ct.length} colors/slots${ctTooltip})`
      const [a, img] = ['a', 'img'].map(tag => document.createElement(tag));
      a.href = generateURL(c, ct);
      a.innerHTML = `<div class="tooltip-origin"><span data-tooltip="${tooltip}"></span></div>`;
      a.querySelector('span').appendChild(img);
      gallery.appendChild(a);
      setTimeout(() => drawGallery(c, ct, img));
      img.onclick = e => {
        e && e.preventDefault();
        e && e.shiftKey ? showMixedVariations(c, ct) :
          (openGallery(c, ct), setCurrentGallery(k));
      };
    });
    updateGallery();
    keepPosition === 'nearest' ? scrollToMidMaybe() :
      (!keepPosition && scrollToMid());
  }
  function drawGallery(coef, ctable, img) {
    draw(coef, ctable, internalCanvas, galleryUnit);
    img.src = internalCanvas.toDataURL('image/png');
  }
  function openGallery(coef, ctable) {
    scrollToTop();
    updateURL();
    setCoef(coef);
    setColorTable(ctable);
  }
  function nextGallery() {nextGalleryGen(+1, c => c > mainCoef, false);}
  function prevGallery() {nextGalleryGen(-1, c => c < mainCoef, true);}
  function nextGalleryGen(step, pred, reversed) {
    isDefaultColorAndGallery() ?
      openGallery(findGallery(pred, reversed), colorTable) : nextSample(step);
  }
  function nextSample(step) {
    const a = galleryImg(), k = getCurrentGalleryIndex();
    const next = positiveMod((k < 0 && step < 0) ? step : (k + step), a.length);
    a[next].onclick();
  }
  function findGallery(pred, reversed) {
    const orig = galleryCoef, a = reversed ? orig.slice().reverse() : orig;
    return a.find(pred) || a[0];
  }
  function updateGallery() {
    galleryImg().forEach((img, k) => {
      img.style.width = img.style.height = galleryPictureSize;
    });
    if (!isDefaultColorAndGallery()) {return;}
    const cur = galleryCoef.indexOf(findGallery(c => c >= mainCoef, false));
    setCurrentGallery(cur);
  }
  function setCurrentGallery(currentIndex) {
    galleryImg().forEach((img, k) => {
      img.dataset.current = yesNo(k === currentIndex);
    });
  }
  function getCurrentGalleryIndex() {
    return galleryImg().findIndex(img => img.dataset.current === yesNo(true));
  }
  function galleryImg() {return [...document.querySelectorAll('#gallery img')];}
  
  // variations
  function showPresetColorVariationsSimply() {
    showPresetColorVariationsGen(mainCoef, null, 'default order', 'nearest');
  }
  function showPresetColorVariations(e) {
    e && e.preventDefault();
    function numSlots(colors) {return colors.length;}
    function numColors(colors) {return uniq(colors).length;}
    const [_, sortingCriterion, info, keepPosition] = [
      ['shiftKey', numSlots, 'sorted by number of color slots', 'nearest'],
      ['ctrlKey', numColors, 'sorted by number of actual colors', 'nearest'],
      ['altKey', null, 'default order', 'nearest'],
      [null, Math.random, 'shuffled', false],
    ].find(([modifier]) => !modifier || (e || {})[modifier]);
    const c = randCoef(Math.max(...colorTableList.map(a => a.length)));
    showPresetColorVariationsGen(c, sortingCriterion, info, keepPosition);
  }
  function showPresetColorVariationsGen(c, sortingCriterion, info, keepPosition) {
    const ctabs = sortingCriterion ?
      sortBy(colorTableList, sortingCriterion) : colorTableList;
    const note = `${ctabs.length} preset colors for c = ${c} (${info})`
    showGallery(ctabs.map(ct => [c, ct]), note, keepPosition);
    const cur = ctabs.findIndex(ct => isSameColorTable(ct, colorTable));
    cur >= 0 && setCurrentGallery(cur);
  }
  function showCoefVariations() {
    const {coefs} = variationNums;
    showVariationsGen(mainCoef, colorTable, {coefs});
  }
  function showColorVariations() {
    const {colors, alts, shuffles} = variationNums;
    showVariationsGen(mainCoef, colorTable, {colors, alts, shuffles});
  }
  function showAltVariations() {
    const alts = altColorVariations;
    const us = uniq(colorTable).length, cs = colorTable.length;
    const note = `${alts} random variations of ${us} colors in ${cs} slots`
    showVariationsGen(mainCoef, colorTable, {alts, note});
  }
  function showDefaultMixedVariations() {
    showVariationsGen(mainCoef, colorTable, mixedVariationNums);
  }
  function showMixedVariations(c, ctable) {
    setCoef(c);
    setColorTable(ctable);
    showDefaultMixedVariations();
  }
  function showVariationsGen(c, ctable, {coefs, colors, alts, shuffles, note}) {
    const shufs = shuffles ? ctable.length - 1 : 0
    const a1 = ntimes(coefs, _ => [randCoef(), ctable]);
    const a2 = ntimes(colors, _ => [c, randomColorTable()]);
    const a3 = ntimes(alts, _ => [c, randomlyReplacedColorTable(ctable)]);
    const a4 = ntimes(shufs, _ => [c, shuffle(ctable)]);
    function noteItem([num, name]) {return num > 0 ? `${name} (${num})` : '';}
    function defaultNote() {
      const a = [[coefs, 'rand param'], [colors, 'rand colors'], [alts, 'alt colors'], [shufs, 'shuffled colors']];
      return a.map(noteItem).filter(s => s).join(' + ');
    }
    showGallery([...a1, ...a2, ...a3, ...a4], note || defaultNote());
  }

  // toast
  let lastToastAnimation = null;
  function toast(message, millisec) {
    lastToastAnimation && lastToastAnimation.finish();
    const tm = Q('#toastMessage');
    tm.innerText = message;
    tm.style.fontSize = (message.length < 20 ? '200%' : '150%');
    const keyframes = [{opacity: 1}, {opacity: 0.8}, {opacity: 0}];
    lastToastAnimation = Q('#toast').animate(keyframes, millisec || 3000);
  }
  
  // misc. actions
  function scrollToTop() {scrollTo('#instruction', 'nearest');}
  function scrollToMid() {scrollTo('#galleryTop', 'start');}
  function scrollToMidMaybe() {scrollTo('#samplesSection', 'nearest');}
  function scrollToBot() {scrollTo('#usage', 'end');}
  function scrollTo(query, block) {
    Q(query).scrollIntoView({behavior: 'smooth', block});
  }
  function rotateResolution() {
    [resolution, mainUnit] = rotate([resolution, mainUnit], resolutionList);
    update(true);
    scrollToTop();
  }
  
  // paste image
  window.addEventListener('paste', e => {
    if (e.target.tagName === 'INPUT') {return;}
    Object.values(e.clipboardData.items).forEach(item => {
      const f = item.type.match('^image/') && item.getAsFile();
      f && loadImage(URL.createObjectURL(f));
    })
  })
  function loadImage(url) {
    toast('Try loading...');
    const img = new Image();
    img.src = Q('#pickColors img').src = url;
    img.onload = () => drawImage(img);
  }
  function drawImage(img) {
    const {width, height} = img;
    const canvas = document.createElement('canvas');
    merge(canvas, {width, height});
    canvas.getContext('2d').drawImage(img, 0, 0);
    pastedImageCanvas = canvas;
    pickColors();
    Q('#pickColors').hidden = false;
  }
  function pickColors() {
    // setup
    const {minColors, maxColors, sets, coefs} = pickedColorsFromPastedImage;
    const canvas = pastedImageCanvas;
    if (!canvas) {return;}
    const {width, height} = canvas, ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, width, height).data;
    // util
    function rgba256(x, y) {
      const k = (x + y * width) * 4, a = imageData.slice(k, k + 4);
      return a.length === 4 ? [...a] : [0, 0, 0, 0];
    }
    function pickOneColor() {
      const [x, y] = [width, height].map(size => rand(size));
      return toRGB(rgba256(x, y));
    }
    function pickColorTable() {
      const colorNum = Math.round(expRand(minColors, maxColors));
      return ntimes(colorNum, pickOneColor);
    }
    // main
    function showPickedVariations() {
      const ts = ntimes(sets, pickColorTable), cs = ntimes(coefs, randCoef);
      const a = ts.flatMap(t => cs.map(c => [c, t]));
      const note = `${sets} color sets were picked randomly from the pasted image.`;
      showGallery(a, note);
    }
    exitFullScreen(showPickedVariations);
}
  
  // util
  function Q(query) {return document.querySelector(query);}
  function merge(target, ...sources) {Object.assign(target, ...sources);}
  function eachKeyValue(h, f) {Object.keys(h).forEach(k => f(k, h[k]));}
  function uniq(ary) {return [...new Set(ary)];}
  function indicesOf(x, ary) {return ary.flatMap((y, j) => x === y ? [j] : []);}
  function ntimes(n, f) {return n ? [...Array(n)].map(f) : [];}
  function toNum(str) {return str - 0;}
    function toHex(c) {return c.toString(16).padStart(2, '0');}
    function toRGB(v) {return `#${v.slice(0, 3).map(toHex).join('')}`};
  function yesNo(bool) {return bool ? 'yes' : 'no';}
  function positiveMod(x, mod) {return (x + mod) % mod;}
  function rand(n) {return Math.floor(Math.random() * n);}
  function unifRand(a, b) {return a + (b - a) * Math.random();}
  function expRand(a, b) {return Math.exp(unifRand(...[a, b].map(Math.log)));}
  function randColorGenerator() {
    function modestRand(modest, range) {
      return Math.round(range * Math.random() ** modest);
    }
    function randomEnhance(enhance) {return enhance ** Math.random();}
    const enh = {s: randomEnhance(randColorEnhance.s),
                 l: randomEnhance(randColorEnhance.l)};
    function randColor() {
      const h = rand(360);
      const s = modestRand(1 / enh.s, 100);
      const lSign = Math.sign(Math.random() - 0.5);
      const l = 50 + lSign * modestRand(enh.l, 50);
      return `hsl(${h},${s}%,${l}%)`;
    }
    return randColor;
  }
  function shuffle(a) {return sortBy(a, Math.random);}
  function sortBy(a, f) {return a.slice().sort((x, y) => f(x) - f(y));}
  function rotate(cur, lis) {
    const conv = JSON.stringify;
    return lis[(lis.map(conv).indexOf(conv(cur)) + 1) % lis.length];
  }
  function deferredProc(proc, delay) {
    let timer;
    return (...args) => {
        clearTimeout(timer); timer = setTimeout(() => proc(...args), delay);
    }
  }
 }
 </script>
 <script defer src="twgl.min.js"></script>
 <script id="vertex_shader" type="non-js">
  attribute vec4 position;
  void main () {gl_Position = position;}
 </script>
 <script id="fragment_shader" type="non-js">
  precision mediump float;
  uniform float resolution, unit, coef, numColors;
  uniform sampler2D colorTexture;
  void main() {
    float center = floor(resolution / 2.0);
    vec2 coord = floor(vec2(gl_FragCoord.x / unit, gl_FragCoord.y / unit)) - center;
    float k = floor(mod(coef * dot(coord, coord), numColors));
    vec4 color = texture2D(colorTexture, vec2((k + 0.5) / numColors, 0.0));
    gl_FragColor = vec4(color.r, color.g, color.b, 1.0);
  }
 </script>
</head>

<body>
<h1>Moire Tapestry - Generative art in 1986</h1>
<p id="instruction">
 Drag the mouse on the picture! (wheel: fine tuning)
</p>
<div id="control">
<div id="mainCanvasContainer"></div>
<div id="colorEditor" hidden>
 <div>
  <span id="colorPickerContainer"></span>
  <input id="groupwise" type="checkbox"></input><label for="groupwise">grouping</label>
  &nbsp;
  <div class="tooltip-origin"><button id="copyColorTable" data-tooltip="Copy to Clipboard">⧉</button></div>
  <div class="tooltip-origin"><span data-tooltip="Paste Here (Ctrl-V or Right-Click)"><input id="pasteColorTable" placeholder="📋"></input></span></div>
 </div>
 <div>
  <button id="acceptColorEditor">Ok</button>
  <button id="cancelColorEditor">Cancel</button>
 </div>
</div>
<div>
 <div class="tooltip-origin"><button id="startAuto" data-tooltip="Start Auto">▶</button><button id="stopAuto" hidden="true" data-tooltip="Stop Auto">⏸</button></div>
 speed <input id="speed" type="range" min="1" max="20" step="1"></input>
 <span class="thin" id="speedVal"></span>
 blur <input id="blur" type="range" min="0" max="1" step="0.01"></input>
 <span class="thin" id="blurVal"></span>
 <div class="tooltip-origin"><button id="prevGallery" data-tooltip="Previous Sample">&lt;</button></div>
 <div class="tooltip-origin"><button id="nextGallery" data-tooltip="Next Sample">&gt;</button></div>
 <div class="tooltip-origin"><button id="showDefaultMixedVariations" data-tooltip="Random Variations">⚃</button></div>
<div class="tooltip-origin"><button id="showColorEditor" data-tooltip="Edit Colors">🖍</button></div>
 <div class="tooltip-origin"><button id="fullScreen" data-tooltip="Full Screen">⤡</button></div>
</div>
</div>
<p>
<span id="state"></span>
c=<input id="coef" type="number" min="0" step="0.0001">
<button id="copyCoef">Copy</button>
&nbsp;
<button id="copyURL">Set &amp; Copy URL</button>
<button id="newTab">New Tab</button>
<a id="download">Download image</a><span>Download image</span>
</p>
<h2>What is this?</h2>
<p>
This is an interactive &amp; colorized version of the article:
<blockquote>
A. K. Dewdney:
"COMPUTER RECREATIONS",
Scientific American,
Vol. 255, No. 3, pp. 14-23,
September 1986.
</blockquote>
<blockquote>
("Wallpaper for the mind: computer images that are almost, but not quite, repetitive")
</blockquote>
The color at the point (x, y) is determined from
<blockquote>
floor(c * (x*x + y*y)) mod <span id="mod"></span>
in <span id="palette"></span>
(<span id="paletteColorNum"></span> colors)
</blockquote>
for the given parameter c.
</p>
<div id="samplesSection">
<h2>Samples</h2>
<span id="galleryTop"></span>
<p id="galleryController">
 size
 <button id="smallGallery">S</button>
 <button id="mediumGallery">M</button>
 <button id="largeGallery">L</button>
 &nbsp;
 <button id="showDefaultGallery">Gallery</button>
 <button id="showPresetColorVariations">Random Gallery</button>
 &nbsp;
 <span class="small">
  <button id="showCoefVariations">rand param</button>
  <button id="showColorVariations">rand colors</button>
  <button id="showAltVariations">alt colors</button>
  <button id="showPresetColorVariationsSimply">preset colors</button>
 </span>
 &nbsp;
 <button id="pickColors" hidden>Retry Image <img id="pastedImageInButton"></button>
</p>
<p id="galleryNote"></p>
<p id="gallery"></p>
</div><!-- samplesSection -->
<h2 id="usage">Tips</h2>
<p>
<ul>
 <li>Horizontal/vertical drag causes fast/slow change of the pattern.</li>
 <li>You can paste any image via clipboard ('Ctrl-v' key, etc.) to pick colors from it.</li>
</ul>
<h2>Shortcut keys</h2>
<p>
<ul>
 <li>Fast change: horizontal drag or '<' / '>' key</li>
 <li>Slow change: vertical drag or ',' / '.' key</li>
 <li>Fine tuning: mouse wheel or '[' / ']' key</li>
 <li>Next/Previous sample: '(' / ')' key</li>
 <li>Copy c to clipboard: 'c' key</li>
 <li>Toggle auto: 'a' key</li>
 <li>Toggle full screen: 'f' key</li>
 <li>Switch sample picture size: 'z' key</li>
 <li>Show random gallery: 'x' key ('Shift/Ctrl/Alt-x' for sorting by "number of color slots" / "number of actual colors" / "default order" instead of shuffling)</li>
 <li>Generate random variations: 'Shift+v' key (or Shift+Click pictures in "Samples" section)</li>
 <li>Pick colors from an image: Copy &amp; paste the image via the clipboard. ('Ctrl+v' key, etc.)</li>
 <li>Scroll to top/middle/bottom: 'g' / 'm' / 'Shift-g' key</li>
</ul>
<h3 class="thin">(experimental)</h3>
<ul class="thin">
 <li>Switch resolutions: 'Shift-r' key</li>
 <li>Toggle GPU: 'Ctrl-Shift-g' key (needs <a href="https://twgljs.org/">twgl.min.js</a>, e.g. <a href="https://github.com/greggman/twgl.js/releases/tag/v4.23.2">v4.23.2</a>)</li>
</ul>
</p>
<h2>Link</h2>
<p>
<a href="https://github.com/kaorahi/moireTapestry">Project Home</a>
</p>
<div id='toast'><p id='toastMessage'></p></div>
</body>
