<!DOCTYPE HTML>
<html>
<head>
 <meta charset="UTF-8" />
 <title>Moire Tapestry</title>
 <style>
  #mainCanvasContainer {
    display: inline-block; margin-bottom: 0.5em; padding: none;
    border: 1px solid black;
    box-shadow: 2px 6px 10px gray; transition: box-shadow 0.2s;
  }
  #mainCanvasContainer:hover {
    box-shadow: 4px 12px 20px black; transition: box-shadow 0.2s;
  }
  #gallery img {
    border: solid 2px transparent; margin: 0.3em; padding: 0;
    box-shadow: 1px 3px 5px gray; transition: transform 0.1s;
  }
  #gallery img[data-current="yes"] {box-shadow: 4px 12px 20px black;}
  #gallery img:hover {
    border: solid 2px blue; transform: scale(1.5); transition: transform 0.1s;
  }
  #control {
    display: inline-block; text-align: center; padding: 2vmin; background: #ccc;
    border-radius: 1vmin;
  }
  #blur, #speed {width: 15vmin;}
  #coef {width: 7em;}
  #coef[data-valid="no"] {background: pink;}
  #download + span {display: none;}
  #download[hidden] + span {display: inline; color: #ddd;}
  #palette span:not(.tooltip-origin) {margin: 1px; padding: 0; border: solid 1px black;}
  .thin {opacity: 0.2;}
  #toast {
   position: fixed; top: 0; left: 0; width: 100%; height: 100%;
   display: flex; justify-content: center; align-items: center;
   opacity: 0; pointer-events: none;
  }
  #toastMessage {
   max-width: 50vw; overflow-wrap: anywhere;
   color: white; background-color: black;
   padding: 0.5em; border-radius: 1em; z-index: 9; position: relative;
  }
  .tooltip-origin {position: relative; display: inline-block;}
  [data-tooltip] {width: 2em; height: 2em;}
  [data-tooltip]:hover:after {
   content: attr(data-tooltip); display: inline-block; position: absolute;
   background-color: #ff9; padding: 0.2em;
   z-index: 9; top: 2em; left: 0em; white-space: nowrap;
  }
  [data-tooltip]:after {content: "";}
  #galleryController {
   background-color: #ddd; padding: 0.2em; position: sticky; top: 0;
  }

 </style>
 <script>
 'use strict'
 window.onload = () => {
  
  // param
  const resolutionList = [[101, 4], [151, 4], [201, 2], [401, 1], [51, 8]];
  let [resolution, mainUnit] = resolutionList[0];
  const mainPictureSize = '70vmin';
  const colorTableList = [
    // light
    [
      'white', 'orange', 'white', 'pink', 'white', 'red',
      'white', 'magenta', 'white', 'yellow', 'white', 'blue',
    ],
    // dense light
    [
      'white', 'brown', 'orange', 'white', 'pink', 'red',
      'white', 'khaki', 'magenta', 'white', 'yellow', 'blue',
    ],
    // red
    [
      'red', 'white', 'red', 'red', 'white', 'white',
      'red', 'navy', 'green', 'white', 'silver', 'gold',
    ],
    // brown
    [
      '#fc9', '#c33', '#633', '#fc9', '#fff', '#cff',
      '#f96', '#cff', '#fff', '#c33', '#f96', '#633',
    ],
    // brown blobs
    [
      '#fc9', '#f96', '#c33', '#633', '#cff', '#fff',
      '#fc9', '#f96', '#c33', '#633', '#cff', '#fff',
    ],
    // black & white
    [
      'black', 'white', 'white', 'white',
      'black', 'white', 'white', 'white',
      'black', 'white', 'white', 'white',
    ],
    // four colors
    [
      '#f00', '#fff', '#fff', '#fff',
      '#366', '#fff', '#fff', '#f60',
      '#00c', '#fff', '#fff', '#fff',
    ],
  ];
  const defaultColorTable = colorTableList[0];
  const maxRandomColors = 16;
  const coefURLDigits = 7;
  const horizontalDragStep = 0.01;
  const verticalDragStep = horizontalDragStep * 0.01;
  const wheelStep = verticalDragStep * 0.001;
  const kbdFastStep = horizontalDragStep;
  const kbdSlowStep = verticalDragStep;
  const kbdFineStep = kbdSlowStep * 0.1;
  const defaultBlur = 0.15, blurDigits = 2;
  const defaultAutoSpeed = 7, autoStep = wheelStep, autoMillisec = 100;
  const doubleTapMillisec = 500, doubleTapDistance = 100;
  const downloadLinkDelayMillisec = 500;
  const variationNums = {coefs: 100, colors: 90, alts: 10, shuffles: true};
  const mixedVariationNums = {coefs: 50, colors: 40, alts: 10, shuffles: true};
  const altColorVariations = 100;
  const randColorEnhance = {s: 5.0, l: 5.0}; // >= 1
  
  // samples
  const galleryCoef = [
    0.1199, 0.1478, 0.3125, 0.6491, 0.6521, 0.7274, 0.7693, 0.7742, 0.8184,
    1.1818, 1.4634, 1.5482, 1.5600, 1.5652, 1.5937,
    2.1419, 2.3566, 2.4080, 2.6071, 2.6143, 2.6341, 2.6352, 2.7694,
    3.5450, 3.5807, 3.6164, 3.7199, 3.7272,
    4.1471, 4.2985, 4.3632, 4.3902, 4.5334, 4.5886, 4.7727,
    5.1179, 5.2108, 5.3794, 5.4286, 5.6188, 5.6343, 5.6400, 5.7097, 5.8076,
    6.2432, 6.2718, 6.3716, 6.3829, 6.3846, 6.5290, 6.6486,
    7.1642, 7.2852, 7.3500, 7.4000, 7.6500, 7.7289,
    8.4782, 8.5385, 8.5389, 8.5455, 8.6129, 8.6412, 8.8333, 8.8415, 8.8800,
    9.3156, 9.6667, 9.8050, 9.8712,
    10.5883, 10.6799, 10.6956, 10.7728,
    11.1891, 11.3906, 11.6500, 11.6758, 11.6799, 11.8064,
  ].sort((a, b) => a - b);
  const galleryUnit = 1;
  const galleryPictureSizeSML = ['5vw', '11vw', '22vw'];
  const defaultCoef = 3.6164;
  
  // state
  let mainCoef = defaultCoef;
  let colorTable = defaultColorTable;
  let useGPU = false;
  let galleryPictureSize = galleryPictureSizeSML[0];
  let autoTimer = null;
  
  // init
  let mainCanvas, internalCanvas;
  const updateDownloadLink = downloadLinkUpdater();
  const [smallGallery, mediumGallery, largeGallery] =
    galleryPictureSizeSML.map(size => () => setGallerySize(size));
  readURL();
  updateCanvas();
  updateCoefForm();
  showDefaultGallery();
  initializeUI();
  update();
  !location.search && startAuto();
  
  // main
  function update(isNewSetting) {
    isNewSetting && updateCanvas();
    normalizeMainCoef();
    draw(mainCoef);
    updateGallery();
  }
  function draw(coef, ctable, canvas, unit) {
    const cv = canvas || mainCanvas;
    const args = [coef, ctable || colorTable, cv, unit || mainUnit];
    const usingGPU = drawGPU(...args) || drawCPU(...args);
    if (cv !== mainCanvas) {return;}
    Q('#state').innerText = usingGPU ? '(GPU) ' : '';
    updateDownloadLink();
  }
  
  // draw
  function drawCPU(coef, ctable, canvas, unit) {
    const g = canvas.getContext('2d');
    const center = Math.floor(resolution / 2);
    function sqr(k) {return k * k;}
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        const k = Math.floor(coef * (sqr(i - center) + sqr(j - center)));
        const style = ctable[k % ctable.length];
        fillSquare(g, i * unit, j * unit, unit, style);
      }
    }
    return false;
  }
  function drawGPU(coef, ctable, canvas, unit) {
    if (!useGPU || !isTwglAvailable()) {return false;}
    const gl = canvas.getContext('webgl');
    if (!gl) {return false;}
    const shaders = ['vertex_shader', 'fragment_shader'];
    const programInfo = twgl.createProgramInfo(gl, shaders);
    const arrays = {position: {numComponents: 2, data: [-1,-1, 1,-1, -1,1, 1,1]}};
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
    const cvec = getColorVectors(ctable);
    // dummy texture to use colorTable in GPU
    const src = cvec.flat(), numColors = cvec.length;
    const colorTexture = twgl.createTexture(gl, {src, width: numColors, height: 1})
    const uniforms = {resolution, unit, coef, numColors, colorTexture};
    gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    twgl.setUniforms(programInfo, uniforms);
    twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLE_STRIP);
    return true;
  }
  function isTwglAvailable() {return typeof twgl !== 'undefined';}
  
  // drag
  function setMouseActions(canvas) {
    let prevPoint = null;
    canvas.onmousedown = e => {prevPoint = mouseEventPoint(e);}
    canvas.onmouseleave = document.onmouseup = e => {prevPoint = null;}
    canvas.onmousemove = e => {
      if (!prevPoint) {return;}
      const point = mouseEventPoint(e);
      const [dx, dy] = [point.x - prevPoint.x, - (point.y - prevPoint.y)];
      const horizontal = Math.abs(dx) > Math.abs(dy);
      addCoef(horizontal ? dx * horizontalDragStep : dy * verticalDragStep);
      prevPoint = point;
    }
    canvas.onwheel = e => {e.preventDefault(); addCoef(e.deltaY * wheelStep);}
    setSwipeActions(canvas);
  }
  function mouseEventPoint(e) {return {x: e.clientX, y: e.clientY};}
  
  // swipe
  function setSwipeActions(canvas) {
    // accept swipe only after double tap
    let swipable = false, lastTap = null;
    const touchEquiv = [
      // [ontouchXXX, onmouseXXX, preProc, postProc]
      ['start', 'down', startTouch, null],
      ['move', 'move', null, null],
      ['end', 'leave', null, endTouch],
      ['cancel', 'leave', null, endTouch],
    ];
    touchEquiv.forEach(([touchName, mouseName, preProc, postProc]) => {
      function maybe(f, ...a) {f && f(...a);}
      canvas['ontouch' + touchName] = e => {
        const t = e.changedTouches[0];  // ignore multi-touch
        if (!t) {return;}
        maybe(preProc, t);
        if (!swipable) {return;}
        canvas['onmouse' + mouseName](t);
        e.preventDefault();
        maybe(postProc);
      }
    });
    // detect double tap
    function startTouch(e) {
      if (swipable) {return;}
      const time = Date.now(), point = mouseEventPoint(e);
      const immediate = lastTap && (time - lastTap.time <= doubleTapMillisec);
      const isDoubleTap = immediate && near(point, lastTap.point);
      const isNewTap = !isDoubleTap;
      swipable = isDoubleTap;
      lastTap = isNewTap && {time, point};
      isNewTap ? showDoubleTapHint() : cancelDoubleTapHint();
    }
    function endTouch() {swipable = false;}
    function near(a, b) {
      function near1(key) {return Math.abs(a[key] - b[key]) <= doubleTapDistance;}
      return ['x', 'y'].every(near1);
    }
    // show hint
    let doubleTapHintTimer = null;
    function showDoubleTapHint() {
      const show = () => toast('Double Tap & Swipe!');
      cancelDoubleTapHint();
      doubleTapHintTimer = setTimeout(show, doubleTapMillisec * 1.1);
    }
    function cancelDoubleTapHint() {clearTimeout(doubleTapHintTimer);}
  }
  
  // keyboard
  document.onkeydown = e => {
    const isStopped = stopAuto();
    if (e.target.tagName === 'INPUT') {return;}
    switch (e.key) {
    case '<': addCoef(- kbdFastStep); break;
    case '>': addCoef(+ kbdFastStep); break;
    case ',': addCoef(- kbdSlowStep); break;
    case '.': addCoef(+ kbdSlowStep); break;
    case '[': addCoef(- kbdFineStep); break;
    case ']': addCoef(+ kbdFineStep); break;
    case '(': prevGallery(); break;
    case ')': nextGallery(); break;
    case 'c': copyCoef(); break;
    case 'a': !isStopped && startAuto(); break;
    case 'f': toggleFullScreen(); break;
    case 'R': [resolution, mainUnit] = rotate([resolution, mainUnit], resolutionList); update(true); break;
    case 'G': e.ctrlKey && (toggleGPU(), e.preventDefault()); break;
    }
  }
  
  // color table
  function copyColorTable() {
    copyToClipboard(JSON.stringify(colorTable));
    setColorTable(colorTable); // to show color table as side effect
  }
  function randomColorTable() {
    const r = Math.random(), n = rand(maxRandomColors - 1) + 2;
    const randColor = randColorGenerator();
    let c = randColor();
    function generateColor() {Math.random() < r && (c = randColor()); return c;}
    const a = [...Array(n)].map(generateColor);
    const isSingleColor = a.every(z => z === a[0]);
    return isSingleColor ? randomColorTable() : shuffle(a);
  }
  function randomlyReplacedColorTable(ctable) {
    const randColor = randColorGenerator();
    const oldColor = [...new Set(ctable)];
    const newColor = oldColor.map(randColor);
    return ctable.map(c => newColor[oldColor.indexOf(c)]);
  }
  function setColorTable(table) {
    colorTable = table;
    update(true);
    updateURL();
  }
  function showColorTable() {
    const container = Q('#palette');
    container.innerHTML = '';
    colorTable.forEach(c => {
      const t = document.createElement('div');
      t.classList.add('tooltip-origin');
      const elem = document.createElement('span');
      elem.style.backgroundColor = c;
      elem.dataset.tooltip = c;
      elem.innerHTML = '&nbsp;';
      container.appendChild(t);
      t.appendChild(elem);
    });
    Q('#paletteColorNum').innerText = new Set(colorTable).size;
  }
  /* function encodeColorTable(a) {return a.join('_');} */
  /* function decodeColorTable(s) {return s.split('_');} */
  function encodeColorTable(a) {return JSON.stringify(a);}
  function decodeColorTable(s) {
    try {return JSON.parse(s);} catch {return defaultColorTable;}
  }
  
  // auto
  function startAuto() {
    cancelAuto();
    const step = Math.pow(2, toNum(Q('#speed').value)) * autoStep;
    autoTimer = setTimeout(() => {addCoef(step); startAuto();}, autoMillisec);
    Q('#startAuto').hidden = true;
    updateAutoButtons(true);
  }
  function stopAuto() {
    const isStopped = !!autoTimer;
    cancelAuto();
    updateAutoButtons(false);
    return isStopped;
  }
  function cancelAuto() {
    autoTimer && clearTimeout(autoTimer);
    autoTimer = null;
  }
  function updateAutoButtons(isStarted) {
    Q('#startAuto').hidden = isStarted;
    Q('#stopAuto').hidden = !isStarted;
  }
  function updateAutoSpeed() {
    Q('#speedVal').innerText = Q('#speed').value.padStart(2, '0');
    autoTimer && startAuto();
  }
  
  // UI parts
  const keepAuto = ['startAuto', 'fullScreen'];
  function initializeUI() {
    initializeButtons();
    initializeSliders();
    function stopAutoMaybe(e) {
      !keepAuto.includes(e.target.id) && (e.target.type !== 'range') && stopAuto();
    }
    document.addEventListener('click', stopAutoMaybe);
    window.onpopstate = e => {readURL(); update(true);};
    merge(Q('#coef'), {
      oninput: setCoefByForm,
      onkeydown: e => {e.key === 'Enter' && (e.target.blur(), updateCoefForm());},
    });
    updateBlur();
    updateAutoSpeed();
  }
  function initializeButtons() {
    // assume "id in HTML" = "function name in JS"
    const buttonAction = {
      copyURL, newTab, nextGallery, prevGallery, startAuto, stopAuto,
      copyCoef, fullScreen,
      smallGallery, mediumGallery, largeGallery,
      copyColorTable,
      showDefaultGallery, showCoefVariations, showColorVariations, showAltVariations,
      showPresetColorVariations, showDefaultMixedVariations,
    }
    function setAction(id, action){Q('#' + id).onclick = action;}
    eachKeyValue(buttonAction, setAction);
  }
  function initializeSliders() {
    const sliderTable = [
      // id, value, oninput
      ['blur', defaultBlur, updateBlur],
      ['speed', defaultAutoSpeed, updateAutoSpeed],
    ];
    function setup([id, value, oninput]) {merge(Q('#' + id), {value, oninput});}
    sliderTable.forEach(setup);
  }
  function setGallerySize(size) {
    galleryPictureSize = size;
    updateGallery();
  }
  function updateBlur() {
    const b = Q('#blur').value;
    mainCanvas.style.filter = `blur(${b}vmin)`;
    Q('#blurVal').innerText = toNum(b).toFixed(blurDigits);
  }
  function downloadLinkUpdater() {
    function updateNow() {
      const href = mainCanvas.toDataURL('image/png');
      const download = `tapestry${encodeCoef(mainCoef)}.png`;
      merge(Q('#download'), {href, download, hidden: false});
    }
    const updateLater = deferredProc(updateNow, downloadLinkDelayMillisec);
    function f() {Q('#download').hidden = true; updateLater();}
    return f;
  }
  function toggleGPU() {
    if (!isTwglAvailable()) {toast('Missing TWGL.js'); return;}
    useGPU = !useGPU;
    removeMainCanvas(); // force reset
    internalCanvas = null; // force reset
    update(true);
    updateURL();
    toast(useGPU ? 'GPU' : 'CPU');
  }
  function fullScreen() {mainCanvas.requestFullscreen();}
  function toggleFullScreen() {
    document.fullscreenElement ? document.exitFullscreen() : fullScreen();
  }
  
  // clipboard
  function copyURL() {updateURL(); copyToClipboard(location.href);}
  function copyToClipboard(text) {
    updateURL();
    navigator.clipboard.writeText(text);
    toast(text);
  }
  
  // coef
  function setCoef(newCoef, byForm) {
    mainCoef = newCoef;
    update();
    !byForm && updateCoefForm();
  }
  function addCoef(d) {setCoef(mainCoef + d);}
  function normalizeMainCoef() {mainCoef = normalizeCoef(mainCoef);}
  function normalizeCoef(coef) {
    function digitizeCoef(num) {return decodeCoef(encodeCoef(num))}
    function positiveMod(k, mod) {return ((k % mod) + mod) % mod;}
    const int = Math.floor(coef), frac = coef - int;
    return digitizeCoef(positiveMod(int, colorTable.length) + frac);
  }
  function encodeCoef(num) {return num.toFixed(coefURLDigits);}
  function decodeCoef(str) {return toNum(str);}
  function updateCoefForm() {
    const form = Q('#coef'), val = encodeCoef(mainCoef);
    form.value = val.includes('.') ? val.replace(/0+$/, '').replace(/[.]$/, '') : val;
    form.dataset.valid = 'yes';
  }
  function setCoefByForm() {
    const form = Q('#coef'), v = form.value, c = toNum(v);
    const valid = v.match(/^\d+[.]?\d*$/) && !Number.isNaN(c);
    form.dataset.valid = valid ? 'yes' : 'no'
    valid && setCoef(c, true);
  }
  function copyCoef() {copyToClipboard(encodeCoef(mainCoef));}
  
  // canvas
  function replaceCanvasMaybe(canvas, unit, pictureSize) {
    // for GPU
    const w = expectedCanvasWidth(unit);
    const resized = !canvas || (canvas.width !== w);
    if (!resized) {return canvas;}
    canvas && canvas.remove();
    const newCanvas = document.createElement('canvas');
    setCanvasSize(newCanvas, unit, pictureSize);
    return newCanvas;
  }
  function updateInternalCanvas() {
    internalCanvas = replaceCanvasMaybe(internalCanvas, galleryUnit, galleryPictureSize);
  }
  function updateMainCanvas() {
    const oldCanvas = mainCanvas;
    mainCanvas = replaceCanvasMaybe(oldCanvas, mainUnit, mainPictureSize);
    if (mainCanvas === oldCanvas) {return;}
    mainCanvas.id = 'mainCanvas';
    Q('#mainCanvasContainer').appendChild(mainCanvas);
  }
  function updateCanvas() {
    updateMainCanvas();
    updateInternalCanvas();
    Q('#mod').innerText = colorTable.length;
    showColorTable();
    setMouseActions(mainCanvas);
    updateBlur();
  }
  function removeMainCanvas() {
    mainCanvas && mainCanvas.remove();
    mainCanvas = null;
  }
  function setCanvasSize(canvas, unit, pictureSize) {
    canvas.width = canvas.height = expectedCanvasWidth(unit);
    canvas.style.width = canvas.style.height = pictureSize;
  }
  function expectedCanvasWidth(unit) {return resolution * unit;}
  
  // graphics
  function fillSquare(g, x, y, size, style) {
    g.fillStyle = style;
    g.beginPath(); g.rect(x, y, size, size); g.fill();
  }
  function getColorVectors(colors) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 1;
    const ctx = canvas.getContext('2d');
    function rgbaVec(colorString) {
      fillSquare(ctx, 0, 0, 1, colorString);
      return [...ctx.getImageData(0, 0, 1, 1).data];
    }
    return colors.map(rgbaVec);
  }
  
  // URL
  function readURL() {
    colorTable = defaultColorTable;
    new URLSearchParams(location.search).forEach((value, key) => {
      switch (key) {
      case 'c': mainCoef = decodeCoef(value); break;
      case 'GPU': useGPU = true; break;
      case 'palette': colorTable = decodeColorTable(value); break;
      }
    })
  }
  function updateURL() {
    const url = generateURL(mainCoef);
    url !== location.href && history.pushState(null, document.title, url);
  }
  function newTab() {
    updateURL();
    window.open(generateURL(mainCoef), '_blank');
  }
  function generateURL(coef, optionColorTable) {
    const url = new URL(location.toString());
    const params = new URLSearchParams('');
    params.append('c', encodeCoef(coef));
    useGPU && params.append('GPU', 'y');
    const ctab = optionColorTable || colorTable;
    const [ct, dct] = [ctab, defaultColorTable].map(encodeColorTable);
    ct && ct !== dct && params.append('palette', ct);
    url.search = params.toString();
    return url.toString();
  }
  
  // gallery
  function showDefaultGallery() {
    showGallery(galleryCoef.map(c => [c, defaultColorTable]), true, true);
  }
  function isShowingDefaultGallery() {return Q('#showDefaultGallery').disabled;} // fixme!
  function showGallery(ary, keepPosition, isDefaultGallery) {
    Q('#showDefaultGallery').disabled = isDefaultGallery;
    Q('#galleryNote').hidden = !isDefaultGallery;
    const gallery = Q('#gallery');
    gallery.innerHTML = '';
    Q('#samples').innerText = galleryCoef.length;
    ary.forEach(([c0, ct]) => {
      const c = normalizeCoef(c0);
      const [a, img] = ['a', 'img'].map(tag => document.createElement(tag));
      a.href = generateURL(c, ct);
      a.appendChild(img);
      gallery.appendChild(a);
      setTimeout(() => drawGallery(c, ct, img));
      a.onclick = e => {
        e.preventDefault();
        e.shiftKey ? showMixedVariations(c, ct) : openGallery(c, ct);
      }
    });
    updateGallery();
    !keepPosition && gallery.scrollIntoView({behavior: 'smooth', block: 'start'});
  }
  function drawGallery(coef, ctable, img) {
    draw(coef, ctable, internalCanvas, galleryUnit);
    img.src = internalCanvas.toDataURL('image/png');
  }
  function openGallery(coef, ctable) {
    Q('#instruction').scrollIntoView({behavior: 'smooth', block: 'nearest'});
    updateURL();
    setCoef(coef);
    setColorTable(ctable);
  }
  function nextGallery() {nextGalleryGen(c => c > mainCoef, false);}
  function prevGallery() {nextGalleryGen(c => c < mainCoef, true);}
  function nextGalleryGen(pred, reversed) {
    openGallery(findGallery(pred, reversed), colorTable);
  }
  function findGallery(pred, reversed) {
    const orig = galleryCoef, a = reversed ? orig.slice().reverse() : orig;
    return a.find(pred) || a[0];
  }
  function updateGallery() {
    const cur = (colorTable === defaultColorTable) &&
      isShowingDefaultGallery() &&
      galleryCoef.indexOf(findGallery(c => c >= mainCoef, false));
    galleryImg().forEach((img, k) => {
      img.dataset.current = (k === cur) ? 'yes' : 'no';
      img.style.width = img.style.height = galleryPictureSize;
    });
  }
  function galleryImg() {return document.querySelectorAll('#gallery img');}
  
  // variations
  function showPresetColorVariations() {
    showGallery(colorTableList.map(ct => [mainCoef, ct]));
  }
  function showCoefVariations() {
    const {coefs} = variationNums;
    showVariationsGen(mainCoef, colorTable, {coefs});
  }
  function showColorVariations() {
    const {colors, alts, shuffles} = variationNums;
    showVariationsGen(mainCoef, colorTable, {colors, alts, shuffles});
  }
  function showAltVariations() {
    showVariationsGen(mainCoef, colorTable, {alts: altColorVariations});
  }
  function showDefaultMixedVariations() {
    showVariationsGen(mainCoef, colorTable, mixedVariationNums);
  }
  function showMixedVariations(c, ctable) {
    setCoef(c);
    setColorTable(ctable);
    showDefaultMixedVariations();
  }
  function showVariationsGen(c, ctable, {coefs, colors, alts, shuffles}) {
    function ntimes(n, f) {return n ? [...Array(n)].map(f) : [];}
    const a1 = ntimes(coefs, _ => [Math.random() * ctable.length, ctable]);
    const a2 = ntimes(colors, _ => [c, randomColorTable()]);
    const a3 = ntimes(alts, _ => [c, randomlyReplacedColorTable(ctable)]);
    const a4 = shuffles ? ntimes(ctable.length - 1, _ => [c, shuffle(ctable)]) : [];
    showGallery([...a1, ...a2, ...a3, ...a4]);
  }
  
  // toast
  let lastToastAnimation = null;
  function toast(message, millisec) {
    lastToastAnimation && lastToastAnimation.finish();
    const tm = Q('#toastMessage');
    tm.innerText = message;
    tm.style.fontSize = (message.length < 20 ? '200%' : '150%');
    const keyframes = [{opacity: 1}, {opacity: 0.8}, {opacity: 0}];
    lastToastAnimation = Q('#toast').animate(keyframes, millisec || 3000);
  }
  
  // util
  function Q(query) {return document.querySelector(query);}
  function merge(target, ...sources) {Object.assign(target, ...sources);}
  function eachKeyValue(h, f) {Object.keys(h).forEach(k => f(k, h[k]));}
  function toNum(str) {return str - 0;}
  function rand(n) {return Math.floor(Math.random() * n);}
  function randColorGenerator() {
    function modestRand(modest, range) {
      return Math.round(range * Math.random() ** modest);
    }
    function randomEnhance(enhance) {return enhance ** Math.random();}
    const enh = {s: randomEnhance(randColorEnhance.s),
                 l: randomEnhance(randColorEnhance.l)};
    function randColor() {
      const h = rand(360);
      const s = modestRand(1 / enh.s, 100);
      const lSign = Math.sign(Math.random() - 0.5);
      const l = 50 + lSign * modestRand(enh.l, 50);
      return `hsl(${h},${s}%,${l}%)`;
    }
    return randColor;
  }
  function shuffle(a) {return a.slice().sort(() => Math.sign(Math.random() - 0.5));}
  function rotate(cur, lis) {
    const conv = JSON.stringify;
    return lis[(lis.map(conv).indexOf(conv(cur)) + 1) % lis.length];
  }
  function deferredProc(proc, delay) {
    let timer;
    return (...args) => {
        clearTimeout(timer); timer = setTimeout(() => proc(...args), delay);
    }
  }
 }
 </script>
 <script defer src="twgl.min.js"></script>
 <script id="vertex_shader" type="non-js">
  attribute vec4 position;
  void main () {gl_Position = position;}
 </script>
 <script id="fragment_shader" type="non-js">
  precision mediump float;
  uniform float resolution, unit, coef, numColors;
  uniform sampler2D colorTexture;
  void main() {
    float center = floor(resolution / 2.0);
    vec2 coord = floor(vec2(gl_FragCoord.x / unit, gl_FragCoord.y / unit)) - center;
    float k = floor(mod(coef * dot(coord, coord), numColors));
    vec4 color = texture2D(colorTexture, vec2((k + 0.5) / numColors, 0.0));
    gl_FragColor = vec4(color.r, color.g, color.b, 1.0);
  }
 </script>
</head>

<body>
<h1>Moire Tapestry - Generative art in 1986</h1>
<p id="instruction">
 Drag the mouse on the picture! (wheel: fine tuning)
</p>
<div id="control">
<div id="mainCanvasContainer"></div>
<div>
 <div class="tooltip-origin"><button id="startAuto" data-tooltip="Start Auto">▶</button><button id="stopAuto" hidden="true" data-tooltip="Stop Auto">⏸</button></div>
 speed <input id="speed" type="range" min="1" max="20" step="1"></input>
 <span class="thin" id="speedVal"></span>
 blur <input id="blur" type="range" min="0" max="1" step="0.01"></input>
 <span class="thin" id="blurVal"></span>
 <div class="tooltip-origin"><button id="prevGallery" data-tooltip="Previous Sample">&lt;</button></div>
 <div class="tooltip-origin"><button id="nextGallery" data-tooltip="Next Sample">&gt;</button></div>
 <div class="tooltip-origin"><button id="showDefaultMixedVariations" data-tooltip="Variations">！</button></div>
 <div class="tooltip-origin"><button id="fullScreen" data-tooltip="Full Screen">⤢</button></div>
</div>
</div>
<p>
<span id="state"></span>
c=<input id="coef" type="number" min="0" step="0.0001">
<button id="copyCoef">Copy</button>
&nbsp;
<button id="copyURL">Set &amp; Copy URL</button>
<button id="newTab">New Tab</button>
<a id="download">Download image</a><span>Download image</span>
</p>
<h2>What is this?</h2>
<p>
This is an interactive &amp; colorized version of the article:
<blockquote>
A. K. Dewdney:
"COMPUTER RECREATIONS",
Scientific American,
Vol. 255, No. 3, pp. 14-23,
September 1986.
</blockquote>
<blockquote>
("Wallpaper for the mind: computer images that are almost, but not quite, repetitive")
</blockquote>
The color at the point (x, y) is determined from
<blockquote>
floor(c * (x*x + y*y)) mod <span id="mod"></span>
in <span id="palette"></span>
(<span id="paletteColorNum"></span> colors)
<button id="copyColorTable">Copy</button>
</blockquote>
for the given parameter c.
</p>
<h2>Samples</h2>
<p id="galleryController">
 size
 <button id="smallGallery">S</button>
 <button id="mediumGallery">M</button>
 <button id="largeGallery">L</button>
 &nbsp;
 <button id="showDefaultGallery">Gallery</button>
 <button id="showPresetColorVariations">Preset Colors</button>
 <button id="showCoefVariations">Random Param</button>
 <button id="showColorVariations">Random Colors</button>
 <button id="showAltVariations">Alt Colors</button>
</p>
<p id="galleryNote">
These <span id="samples"></span> patterns are generated
from just one parameter c without randomness.
</p>
<p id="gallery"></p>
<h2>Advanced usage</h2>
<p>
<ul>
 <li>Fast change: horizontal drag or '<' / '>' key</li>
 <li>Slow change: vertical drag or ',' / '.' key</li>
 <li>Fine tuning: mouse wheel or '[' / ']' key</li>
 <li>Next/Previous sample: '(' / ')' key</li>
 <li>Copy c to clipboard: 'c' key</li>
 <li>Toggle auto: 'a' key</li>
 <li>Toggle full screen: 'f' key</li>
 <li>Show variations: Shift+Click pictures in "Samples" section</li>
</ul>
<h3 class="thin">(experimental)</h3>
<ul class="thin">
 <li>Switch resolutions: 'Shift-r' key</li>
 <li>Toggle GPU: 'Ctrl-Shift-g' key (needs <a href="https://twgljs.org/">twgl.min.js</a>, e.g. <a href="https://github.com/greggman/twgl.js/releases/tag/v4.23.2">v4.23.2</a>)</li>
</ul>
</p>
<h2>Link</h2>
<p>
<a href="https://github.com/kaorahi/moireTapestry">Project Home</a>
</p>
<div id='toast'><p id='toastMessage'></p></div>
</body>
