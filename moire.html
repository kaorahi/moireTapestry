<!DOCTYPE HTML>
<html>
<head>
 <meta charset="UTF-8" />
 <title>Moire Tapestry</title>
 <style>
  #mainCanvasContainer {
    display: inline-block; margin-bottom: 0.5em; padding: none;
    border: 1px solid black;
    box-shadow: 2px 6px 10px gray; transition: box-shadow 0.2s;
  }
  #mainCanvasContainer:hover {
    box-shadow: 4px 12px 20px black; transition: box-shadow 0.2s;
  }
  #gallery img {
    border: solid 2px transparent; margin: 0.3em; padding: 0;
    box-shadow: 1px 3px 5px gray; transition: transform 0.1s;
  }
  #gallery img[data-current="yes"] {box-shadow: 4px 12px 20px black;}
  #gallery img.dup {border: solid 10px red;}
  #gallery img:hover {
    border: solid 2px blue; transform: scale(1.5); transition: transform 0.1s;
  }
  #control {
    display: inline-block; text-align: center; padding: 2vmin; background: #ccc;
    border-radius: 1vmin;
  }
  #blur, #speed {width: 15vmin;}
  #coef {width: 7em;}
  #coef[data-valid="no"] {background: pink;}
  .thin {opacity: 0.2;}
  #toast {
   position: fixed; top: 0; left: 0; width: 100%; height: 100%;
   display: flex; justify-content: center; align-items: center;
   opacity: 0; pointer-events: none;
  }
  #toast p {
   font-size: 200%; color: white; background-color: black;
   padding: 0.5em; border-radius: 1em; z-index: 9; position: relative;
  }
  .tooltip-origin {position: relative; display: inline-block;}
  [data-tooltip] {width: 2em; height: 2em;}
  [data-tooltip]:hover:after {
   content: attr(data-tooltip); display: inline-block; position: absolute;
   background-color: #ff9; padding: 0.2em;
   z-index: 9; top: 2em; left: 0em; white-space: nowrap;
  }
  [data-tooltip]:after {content: "";}

 </style>
 <script>
 'use strict'
 window.onload = () => {
  
  // param
  const resolutionList = [[101, 4], [151, 4], [201, 2], [401, 1], [51, 8]];
  let [resolution, mainUnit] = resolutionList[0];
  const mainPictureSize = '70vmin';
  const colorTableList = [
    [
      'white', 'orange', 'white', 'pink', 'white', 'red',
      'white', 'magenta', 'white', 'yellow', 'white', 'blue',
    ],
    [
      'white', 'brown', 'orange', 'white', 'pink', 'red',
      'white', 'khaki', 'magenta', 'white', 'yellow', 'blue',
    ],
    [
      '#fc9', '#f96', '#c33', '#633', '#cff', '#fff',
      '#fc9', '#f96', '#c33', '#633', '#cff', '#fff',
    ],
    [
      'black', 'white', 'white', 'white',
      'black', 'white', 'white', 'white',
      'black', 'white', 'white', 'white',
    ],
    [
      '#f00', '#fff', '#fff', '#fff',
      '#366', '#fff', '#fff', '#f60',
      '#00c', '#fff', '#fff', '#fff',
    ],
  ];
  let colorTable = colorTableList[0];
  const similarCoefDelta = [6];  // (coef + delta) gives almost similar result
  const coefURLDigits = 7;
  const horizontalDragStep = 0.01;
  const verticalDragStep = horizontalDragStep * 0.01;
  const wheelStep = verticalDragStep * 0.001;
  const kbdFastStep = horizontalDragStep;
  const kbdSlowStep = verticalDragStep;
  const kbdFineStep = kbdSlowStep * 0.1;
  const defaultBlur = 0.15, blurDigits = 2;
  const defaultAutoSpeed = 5, autoStep = kbdFineStep * 0.05, autoMillisec = 100;
  
  // samples
  const galleryCoef = [
    0.1199, 0.1478, 0.3125, 0.6491, 0.6521, 0.7274, 0.7693, 0.7742, 0.8184,
    1.1818, 1.4634, 1.5482, 1.5600, 1.5652, 1.5937,
    2.1419, 2.3566, 2.4080, 2.6071, 2.6143, 2.6341, 2.6352, 2.7694,
    3.5450, 3.5807, 3.6164, 3.7199, 3.7272,
    4.1471, 4.2985, 4.3632, 4.3902, 4.5334, 4.5886, 4.7727,
    5.1179, 5.2108, 5.3794, 5.4286, 5.6188, 5.6343, 5.6400, 5.7097, 5.8076,
    6.2432, 6.2718, 6.3716, 6.3829, 6.3846, 6.5290, 6.6486,
    7.1642, 7.2852, 7.3500, 7.4000, 7.6500, 7.7289,
    8.4782, 8.5385, 8.5389, 8.5455, 8.6129, 8.6412, 8.8333, 8.8415, 8.8800,
    9.3156, 9.6667, 9.8050, 9.8712,
    10.5883, 10.6799, 10.6956, 10.7728,
    11.1891, 11.3906, 11.6500, 11.6758, 11.6799, 11.8064,
  ].sort((a, b) => a - b);
  const galleryUnit = 1, galleryPictureSize = '5';
  const defaultCoef = 3.6164;
  
  // state
  let mainCoef = defaultCoef;
  let useGPU = false;
  let autoTimer = null;
  
  // init
  const internalCanvas = document.createElement('canvas');
  let mainCanvas, colorVec;
  readURL();
  updateCanvas();
  updateCoefForm();
  insertGallery();
  warnSimilarGallery();
  initializeUI();
  update();
  !location.search && startAuto();
  
  // main
  function update(isNewSetting) {
    isNewSetting && updateCanvas();
    normalizeMainCoef();
    draw(mainCoef);
    updateGallery();
  }
  function draw(coef, canvas, unit) {
    const cv = canvas || mainCanvas;
    const args = [coef, cv, unit || mainUnit];
    const usingGPU = drawGPU(...args) || drawCPU(...args);
    if (cv !== mainCanvas) {return;}
    Q('#state').innerText = usingGPU ? '(GPU) ' : '';
    updateDownloadLink();
  }
  
  // draw
  function drawCPU(coef, canvas, unit) {
    const g = canvas.getContext('2d');
    const center = Math.floor(resolution / 2);
    function sqr(k) {return k * k;}
    for (let i = 0; i < resolution; i++) {
      for (let j = 0; j < resolution; j++) {
        const k = Math.floor(coef * (sqr(i - center) + sqr(j - center)));
        const style = colorTable[k % colorTable.length];
        fillSquare(g, i * unit, j * unit, unit, style);
      }
    }
    return false;
  }
  function drawGPU(coef, canvas, unit) {
    if (!useGPU || typeof twgl === 'undefined') {return false;}
    const gl = canvas.getContext('webgl');
    if (!gl) {return false;}
    const shaders = ['vertex_shader', 'fragment_shader'];
    const programInfo = twgl.createProgramInfo(gl, shaders);
    const arrays = {position: {numComponents: 2, data: [-1,-1, 1,-1, -1,1, 1,1]}};
    const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
    // dummy texture to use colorTable in GPU
    const src = colorVec.flat(), numColors = colorVec.length;
    const colorTexture = twgl.createTexture(gl, {src, width: numColors, height: 1})
    const uniforms = {resolution, unit, coef, numColors, colorTexture};
    gl.useProgram(programInfo.program);
    twgl.setBuffersAndAttributes(gl, programInfo, bufferInfo);
    twgl.setUniforms(programInfo, uniforms);
    twgl.drawBufferInfo(gl, bufferInfo, gl.TRIANGLE_STRIP);
    return true;
  }
  
  // drag
  function setMouseActions(canvas) {
    let prevPoint = null;
    function eventPoint(e) {return {x: e.clientX, y: e.clientY};}
    canvas.onmousedown = e => {prevPoint = eventPoint(e);}
    canvas.onmouseleave = document.onmouseup = e => {prevPoint = null; update();}
    canvas.onmousemove = e => {
      if (!prevPoint) {return;}
      const point = eventPoint(e);
      const [dx, dy] = [point.x - prevPoint.x, - (point.y - prevPoint.y)];
      const horizontal = Math.abs(dx) > Math.abs(dy);
      addCoef(horizontal ? dx * horizontalDragStep : dy * verticalDragStep);
      prevPoint = point;
    }
    canvas.onwheel = e => {e.preventDefault(); addCoef(e.deltaY * wheelStep);}
    setSwipeActions(canvas);
  }
  
  // swipe
  function setSwipeActions(canvas) {
    const touchEquiv = [
      // ontouchXXX <==> onmouseXXX
      ['start', 'down'],
      ['move', 'move'],
      ['end', 'leave'],
      ['cancel', 'leave'],
    ];
    touchEquiv.forEach(([touchName, mouseName]) => {
      canvas['ontouch' + touchName] = e => {
        const t = e.changedTouches[0];  // ignore multi-touch
        if (!t) {return;}
        canvas['onmouse' + mouseName](t);
        e.preventDefault();
      }
    });
  }
  
  // keyboard
  document.onkeydown = e => {
    const isStopped = stopAuto();
    if (e.target.tagName === 'INPUT') {return;}
    switch (e.key) {
    case '<': addCoef(- kbdFastStep); break;
    case '>': addCoef(+ kbdFastStep); break;
    case ',': addCoef(- kbdSlowStep); break;
    case '.': addCoef(+ kbdSlowStep); break;
    case '[': addCoef(- kbdFineStep); break;
    case ']': addCoef(+ kbdFineStep); break;
    case 'c': copyCoef(); break;
    case 'a': !isStopped && startAuto(); break;
    case 'f': toggleFullScreen(); break;
    case 'C': colorTable = rotate(colorTable, colorTableList); update(true); break;
    case 'R': [resolution, mainUnit] = rotate([resolution, mainUnit], resolutionList); update(true); break;
    case 'V': e.ctrlKey && (openVariations(), e.preventDefault()); break;
    }
  }
  
  // auto
  function startAuto() {
    cancelAuto();
    const step = Math.pow(2, toNum(Q('#speed').value)) * autoStep;
    autoTimer = setTimeout(() => {addCoef(step); startAuto();}, autoMillisec);
    Q('#startAuto').hidden = true;
    updateAutoButtons(true);
  }
  function stopAuto() {
    const isStopped = !!autoTimer;
    cancelAuto();
    updateAutoButtons(false);
    return isStopped;
  }
  function cancelAuto() {
    autoTimer && clearTimeout(autoTimer);
    autoTimer = null;
  }
  function updateAutoButtons(isStarted) {
    Q('#startAuto').hidden = isStarted;
    Q('#stopAuto').hidden = !isStarted;
  }
  function updateAutoSpeed() {
    Q('#speedVal').innerText = Q('#speed').value.padStart(2, '0');
    autoTimer && startAuto();
  }
  
  // UI parts
  const keepAuto = ['startAuto', 'fullScreen'];
  function initializeUI() {
    initializeButtons();
    initializeSliders();
    function stopAutoMaybe(e) {
      !keepAuto.includes(e.target.id) && (e.target.type !== 'range') && stopAuto();
    }
    document.addEventListener('click', stopAutoMaybe);
    window.onpopstate = e => {readURL(); update();};
    merge(Q('#coef'), {
      oninput: setCoefByForm,
      onkeydown: e => {e.key === 'Enter' && (e.target.blur(), updateCoefForm());},
    });
    updateBlur();
    updateAutoSpeed();
  }
  function initializeButtons() {
    // assume "id in HTML" = "function name in JS"
    const buttonAction = {
      copyURL, newTab, nextGallery, prevGallery, startAuto, stopAuto,
      copyCoef, fullScreen,
    }
    function setAction(id, action){Q('#' + id).onclick = action;}
    eachKeyValue(buttonAction, setAction);
  }
  function initializeSliders() {
    const sliderTable = [
      // id, value, oninput
      ['blur', defaultBlur, updateBlur],
      ['speed', defaultAutoSpeed, updateAutoSpeed],
      ['gallerySize', galleryPictureSize, updateGallery],
    ];
    function setup([id, value, oninput]) {merge(Q('#' + id), {value, oninput});}
    sliderTable.forEach(setup);
  }
  function updateBlur() {
    const b = Q('#blur').value;
    mainCanvas.style.filter = `blur(${b}vmin)`;
    Q('#blurVal').innerText = toNum(b).toFixed(blurDigits);
  }
  function updateDownloadLink() {
    const href = mainCanvas.toDataURL('image/png');
    const download = `tapestry${encodeCoef(mainCoef)}.png`;
    merge(Q('#download'), {href, download});
  }
  function fullScreen() {mainCanvas.requestFullscreen();}
  function toggleFullScreen() {
    document.fullscreenElement ? document.exitFullscreen() : fullScreen();
  }
  
  // clipboard
  function copyURL() {copyToClipboard(location.href);}
  function copyToClipboard(text) {
    updateURL();
    navigator.clipboard.writeText(text);
    toast(text);
  }
  
  // coef
  function setCoef(newCoef, byForm) {
    mainCoef = newCoef;
    update();
    !byForm && updateCoefForm();
  }
  function addCoef(d) {setCoef(mainCoef + d);}
  function normalizeMainCoef() {mainCoef = normalizeCoef(mainCoef);}
  function normalizeCoef(coef) {
    function digitizeCoef(num) {return decodeCoef(encodeCoef(num))}
    function positiveMod(k, mod) {return ((k % mod) + mod) % mod;}
    const int = Math.floor(coef), frac = coef - int;
    return digitizeCoef(positiveMod(int, colorTable.length) + frac);
  }
  function encodeCoef(num) {return num.toFixed(coefURLDigits);}
  function decodeCoef(str) {return toNum(str);}
  function updateCoefForm() {
    const form = Q('#coef'), val = encodeCoef(mainCoef);
    form.value = val.includes('.') ? val.replace(/0+$/, '').replace(/[.]$/, '') : val;
    form.dataset.valid = 'yes';
  }
  function setCoefByForm() {
    const form = Q('#coef'), v = form.value, c = toNum(v);
    const valid = v.match(/^\d+[.]?\d*$/) && !Number.isNaN(c);
    form.dataset.valid = valid ? 'yes' : 'no'
    valid && setCoef(c, true);
  }
  function copyCoef() {copyToClipboard(encodeCoef(mainCoef));}
  
  // canvas
  function updateCanvas() {
    replaceMainCanvas();
    setCanvasSize(mainCanvas, mainUnit, mainPictureSize);
    setCanvasSize(internalCanvas, galleryUnit, galleryPictureSize);
    colorVec = getColorVectors(colorTable);
    Q('#mod').innerText = colorTable.length;
    setMouseActions(mainCanvas);
    updateBlur();
  }
  function replaceMainCanvas() {
    mainCanvas && mainCanvas.remove();
    mainCanvas = document.createElement('canvas');
    mainCanvas.id = 'mainCanvas';
    Q('#mainCanvasContainer').appendChild(mainCanvas);
  }
  function setCanvasSize(canvas, unit, pictureSize) {
    canvas.width = canvas.height = resolution * unit;
    canvas.style.width = canvas.style.height = pictureSize;
  }
  
  // graphics
  function fillSquare(g, x, y, size, style) {
    g.fillStyle = style;
    g.beginPath(); g.rect(x, y, size, size); g.fill();
  }
  function getColorVectors(colors) {
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = 1;
    const ctx = canvas.getContext('2d');
    function rgbaVec(colorString) {
      fillSquare(ctx, 0, 0, 1, colorString);
      return [...ctx.getImageData(0, 0, 1, 1).data];
    }
    return colors.map(rgbaVec);
  }
  
  // URL
  function readURL() {
    new URLSearchParams(location.search).forEach((value, key) => {
      switch (key) {
      case 'c': mainCoef = decodeCoef(value); break;
      case 'GPU': useGPU = true; break;
      }
    })
  }
  function updateURL() {
    const url = generateURL(mainCoef);
    url !== location.href && history.pushState(null, document.title, url);
  }
  function generateURL(coef) {
    const url = new URL(location.toString());
    const params = new URLSearchParams('');
    params.append('c', encodeCoef(coef));
    useGPU && params.append('GPU', 'y');
    url.search = params.toString();
    return url.toString();
  }
  
  // new tab
  function newTab(f) {newTabForCoef(mainCoef);}
  function openVariations() {
    colorTable.forEach((_, k) => (k > 0) && newTabForCoef(mainCoef + k));
  }
  function newTabForCoef(coef) {
    updateURL();
    window.open(generateURL(coef), '_blank');
  }
  
  // gallery
  function insertGallery() {
    const gallery = Q('#gallery');
    Q('#samples').innerText = galleryCoef.length;
    galleryCoef.forEach(c => {
      const [a, img] = ['a', 'img'].map(tag => document.createElement(tag));
      a.href = generateURL(c);
      a.appendChild(img);
      gallery.appendChild(a);
      setTimeout(() => drawGallery(c, img));
      a.onclick = e => {e.preventDefault(); openGallery(c);}
    });
  }
  function drawGallery(coef, img) {
    draw(coef, internalCanvas, galleryUnit);
    img.src = internalCanvas.toDataURL('image/png');
  }
  function openGallery(coef) {
    Q('#instruction').scrollIntoView({behavior: 'smooth', block: 'nearest'});
    updateURL();
    setCoef(coef);
    updateURL();
  }
  function nextGallery() {nextGalleryGen(c => c > mainCoef, false);}
  function prevGallery() {nextGalleryGen(c => c < mainCoef, true);}
  function nextGalleryGen(pred, reversed) {openGallery(findGallery(pred, reversed));}
  function findGallery(pred, reversed) {
    const orig = galleryCoef, a = reversed ? orig.slice().reverse() : orig;
    return a.find(pred) || a[0];
  }
  function updateGallery() {
    const cur = galleryCoef.indexOf(findGallery(c => c >= mainCoef, false));
    const size = `${Q('#gallerySize').value}vw`
    galleryImg().forEach((img, k) => {
      img.dataset.current = (k === cur) ? 'yes' : 'no';
      img.style.width = img.style.height = size;
    });
  }
  function warnSimilarGallery() {
    function similar1(a, b, d) {return normalizeCoef(Math.abs(a - b) - d) === 0;}
    function similar(a, b) {return similarCoefDelta.find(d => similar1(a, b, d));}
    galleryImg().forEach((img, k) => {
      const isDup = galleryCoef.findIndex(c => similar(c, galleryCoef[k])) >= 0;
      isDup && img.classList.add('dup');
    });
  }
  function galleryImg() {return document.querySelectorAll('#gallery img');}
  
  // toast
  let lastToastAnimation = null;
  function toast(message, millisec) {
    lastToastAnimation && lastToastAnimation.finish();
    Q('#toastMessage').innerText = message;
    const keyframes = [{opacity: 1}, {opacity: 0.8}, {opacity: 0}];
    lastToastAnimation = Q('#toast').animate(keyframes, millisec || 3000);
  }
  
  // util
  function Q(query) {return document.querySelector(query);}
  function merge(target, ...sources) {Object.assign(target, ...sources);}
  function eachKeyValue(h, f) {Object.keys(h).forEach(k => f(k, h[k]));}
  function toNum(str) {return str - 0;}
  function rotate(cur, lis) {
    const conv = JSON.stringify;
    return lis[(lis.map(conv).indexOf(conv(cur)) + 1) % lis.length];
  }
 }
 </script>
 <script defer src="twgl.min.js"></script>
 <script id="vertex_shader" type="non-js">
  attribute vec4 position;
  void main () {gl_Position = position;}
 </script>
 <script id="fragment_shader" type="non-js">
  precision mediump float;
  uniform float resolution, unit, coef, numColors;
  uniform sampler2D colorTexture;
  void main() {
    float center = floor(resolution / 2.0);
    vec2 coord = floor(vec2(gl_FragCoord.x / unit, gl_FragCoord.y / unit)) - center;
    float k = floor(mod(coef * dot(coord, coord), numColors));
    vec4 color = texture2D(colorTexture, vec2((k + 0.5) / numColors, 0.0));
    gl_FragColor = vec4(color.r, color.g, color.b, 1.0);
  }
 </script>
</head>

<body>
<h1>Moire Tapestry - Generative art in 1986</h1>
<p id="instruction">
 Drag the mouse on the picture! (wheel: fine tuning)
</p>
<div id="control">
<div id="mainCanvasContainer"></div>
<div>
 <div class="tooltip-origin"><button id="startAuto" data-tooltip="Start Auto">▶</button><button id="stopAuto" hidden="true" data-tooltip="Stop Auto">⏸</button></div>
 speed <input id="speed" type="range" min="1" max="15" step="1"></input>
 <span class="thin" id="speedVal"></span>
 blur <input id="blur" type="range" min="0" max="1" step="0.01"></input>
 <span class="thin" id="blurVal"></span>
 <div class="tooltip-origin"><button id="prevGallery" data-tooltip="Previous Sample">&lt;</button></div>
 <div class="tooltip-origin"><button id="nextGallery" data-tooltip="Next Sample">&gt;</button></div>
 <div class="tooltip-origin"><button id="fullScreen" data-tooltip="Full Screen">⤢</button></div>
</div>
</div>
<p>
<span id="state"></span>
c=<input id="coef" type="number" min="0" step="0.0001">
<button id="copyCoef">Copy</button>
&nbsp;
<button id="copyURL">Set &amp; Copy URL</button>
<button id="newTab">New Tab</button>
<a id="download">Download image</a>
</p>
<h2>What is this?</h2>
<p>
This is an interactive &amp; colorized version of the article:
<blockquote>
A. K. Dewdney:
"COMPUTER RECREATIONS",
Scientific American,
Vol. 255, No. 3, pp. 14-23,
September 1986.
</blockquote>
<blockquote>
("Wallpaper for the mind: computer images that are almost, but not quite, repetitive")
</blockquote>
The color at the point (x, y) is determined from
<blockquote>
floor(c * (x*x + y*y)) mod <span id="mod"></span>
</blockquote>
for the given parameter c.
</p>
<h2>Samples</h2>
These <span id="samples"></span> patterns are generated
from just one parameter c without randomness.
<p>size <input id="gallerySize" type="range" min="5" max="40" step="1"></input></p>
<p id="gallery"></p>
<h2>Advanced usage</h2>
<p>
<ul>
 <li>Fast change: horizontal drag or '<' / '>' key</li>
 <li>Slow change: vertical drag or ',' / '.' key</li>
 <li>Fine tuning: mouse wheel or '[' / ']' key</li>
 <li>Copy c to clipboard: 'c' key</li>
 <li>Toggle auto: 'a' key</li>
 <li>Toggle full screen: 'f' key</li>
</ul>
<h3 class="thin">(experimental)</h3>
<ul class="thin">
 <li>Switch colors / resolutions: 'Shift-c' / 'Shift-r' key</li>
 <li>Open variations in new tabs: 'Ctrl-Shift-v' key (may be blocked by the browser)</li>
 <li>Enable GPU: Get <a href="https://twgljs.org/">twgl.min.js</a> (e.g. <a href="https://github.com/greggman/twgl.js/releases/tag/v4.23.2">v4.23.2</a>) and append "&amp;GPU=y" after "?c=x.xxxx" in the URL.</li>
</ul>
</p>
<h2>Link</h2>
<p>
<a href="https://github.com/kaorahi/moireTapestry">Project Home</a>
</p>
<div id='toast'><p id='toastMessage'></p></div>
</body>
